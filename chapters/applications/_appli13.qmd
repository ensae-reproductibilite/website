::: {.application}

## Application 13: cr√©ation de l'image `Docker`

Se placer dans un environnement avec `Docker`, par
exemple _[Play with Docker](https://labs.play-with-docker.com)_

#### Cr√©ation du `Dockerfile`

- Dans le terminal `Linux`, cloner votre d√©p√¥t `Github`
- Repartir du dernier _checkpoint_ mis √† disposition (ou de votre derni√®re version si vous la pr√©f√©rez). 

- Cr√©er via la ligne de commande un fichier texte vierge nomm√© `Dockerfile` (la majuscule au d√©but du mot est importante)

<details><summary>Commande pour cr√©er un `Dockerfile` vierge depuis la ligne de commande</summary>
```{.bash filename="terminal"}
touch Dockerfile
```
</details>

- Ouvrir ce fichier via un √©diteur de texte et copier le contenu suivant dedans:

<details><summary>Premier `Dockerfile`</summary>

```{.bash filename="terminal" no-prefix=true}
FROM ubuntu:22.04

# Install Python
RUN apt-get -y update && \
    apt-get install -y python3-pip curl

# Install uv
RUN curl -LsSf https://astral.sh/uv/install.sh | sh
ENV PATH="/root/.local/bin/:$PATH"

# Install project dependencies
COPY pyproject.toml .
RUN uv sync

CMD ["uv", "run", "main.py"]
```
</details>

#### Construire (_build_) l'image

- Utiliser `docker build` pour cr√©er une image avec le tag `my-python-app`

```{.bash filename="terminal"}
docker build . -t my-python-app
```

- V√©rifier les images dont vous disposez. Vous devriez avoir un r√©sultat proche de celui-ci :

```{.bash filename="terminal"}
docker images
```

```{.python}
REPOSITORY      TAG       IMAGE ID       CREATED          SIZE
my-python-app   latest    e83445c6fb5a   12 seconds ago   978MB
```

#### Tester l'image: d√©couverte du cache

L'√©tape de `build` a fonctionn√©: une image a √©t√© construite.

Mais fait-elle effectivement ce que l'on attend d'elle ?

Pour le savoir, il faut passer √† l'√©tape suivante, l'√©tape de `run`.

```{.bash filename="terminal"}
docker run -it my-python-app
```

```{.python}
python3: can't open file '/~/titanic/main.py': [Errno 2] No such file or directory
```

Le message d'erreur est clair : `Docker` ne sait pas o√π trouver le fichier `main.py`. D'ailleurs, il ne connait pas non plus les autres fichiers de notre application qui sont n√©cessaires pour faire tourner le code, par exemple le dossier `src`.

- Avant l'√©tape `CMD`, copier les fichiers n√©cessaires sur l'image afin que l'application dispose de tous les √©l√©ments n√©cessaires pour √™tre en mesure de fonctionner.

<details>
<summary>Nouveau `Dockerfile` </summary>

```{.bash filename="terminal" no-prefix=true}
FROM ubuntu:22.04

# Install Python
RUN apt-get -y update && \
    apt-get install -y python3-pip curl

# Install uv
RUN curl -LsSf https://astral.sh/uv/install.sh | sh
ENV PATH="/root/.local/bin/:$PATH"

# Install project dependencies
COPY pyproject.toml .
RUN uv sync

COPY main.py .
COPY src ./src
CMD ["uv", "run", "main.py"]
```

</details>

- Refaire tourner l'√©tape de `build`

- Refaire tourner l'√©tape de `run`. Il vous manque la variable d'environnement `JETON_API` qui n'a pas √©t√© ins√©r√©e dans le conteneur pour ne pas prendre le risque de la r√©v√©ler. Il va falloir l'introduire au moment du _run_ avec la commande suivante: 

```{.python}
docker run -e JETON_API='' -it my-python-app
```

- A ce stade, l'application doit tourner de A √† Z üéâ.
F√©licitations, vous avez cr√©√© votre premi√®re application reproductible !

:::

::: {.callout-note}

Ici, le _cache_ permet d'√©conomiser beaucoup de temps. Par besoin de
refaire tourner toutes les √©tapes, `Docker` agit de mani√®re intelligente
en faisant tourner uniquement les √©tapes qui ont chang√©.

:::


{{< checkpoint appli13 >}}

