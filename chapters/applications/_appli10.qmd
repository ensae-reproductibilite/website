::: {.application}

## Application 10: packagisation _(optionnel)_

- Depuis la ligne de commande, en se placant dans le dossier racine `~/work`, créer le squelette de notre _package_ avec la commande:

    ```bash
    uv init --lib titanicml
    ``` 

- Copier les sous-dossiers de notre `src/` actuel dans le dossier `src/` crée dans le package titanicml

- Ouvrir le fichier `pyproject.toml` présent dans `titanicml/` et observer la liste des dépendances vide. La gestion des dépendances est un peu plus formelle dans un _package_: c'est ici que la liste des dépendances indispensables à notre projet plutôt que dans un `requirements.txt`. 
- Bien que ceci sera expliqué plus tard, vous pouvez ajouter des dépendances en tapant, en ligne de commande:

    ```bash
    uv add pandas PyYAML scikit-learn python-dotenv duckdb
    ```

Cela devrait mettre à jour le fichier `pyproject.toml` pour qu'il ressemble à ceci:

    ```{.python filename="pyproject.toml"}
    [project]
    name = "titanicml"
    version = "0.1.0"
    description = "Add your description here"
    readme = "README.md"
    authors = [
        { name = "daffyduck", email = "daffy.duck@ensae.fr" }
    ]
    requires-python = ">=3.13"
    dependencies = [
        "duckdb>=1.4.4",
        "pandas>=3.0.0",
        "python-dotenv>=1.2.1",
        "pyyaml>=6.0.3",
        "scikit-learn>=1.8.0",
    ]

    [build-system]
    requires = ["uv_build>=0.9.14,<0.10.0"]
    build-backend = "uv_build"
    ```

- Déplacer les fichiers adéquats en suivant l'aborescence proposée plus haut. 
- Compiler le package avec la commande `uv build`. Cela a créé un _wheel_ (une version compilée) de votre _package_ que nous pouvons installer avec

    ```bash
    pip install dist/titanicml-0.1.0-py3-none-any.whl
    ``` 

- Modifier le contenu de `docs/main.py` pour importer les fonctions de notre _package_ `titanicml` et tester en ligne de commande ce fichier
:::

[^init]: Le fichier `__init__.py` indique à `Python` que le dossier
est un _package_. Il permet de proposer certaines configurations
lors de l'import du _package_. Il permet également de contrôler
les objets exportés (c'est-à-dire mis à disposition de l'utilisateur)
par le _package_ par rapport aux objets internes au _package_.
En le laissant vide, nous allons utiliser ce fichier
pour importer l'ensemble des fonctions de nos sous-modules.
Ce n'est pas la meilleure pratique mais un contrôle plus fin des
objets exportés demanderait un investissement qui ne vaut, ici, pas
le coût.


{{< checkpoint appli10 >}}

