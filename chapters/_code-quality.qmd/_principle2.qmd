::: {.content-visible when-profile="fr"}

# Principe 2Ô∏è‚É£ : favoriser une structure modulaire

## Objectifs

- Favoriser la __concision__ pour r√©duire le risque d'erreur
et rendre la d√©marche plus claire ;
- Am√©liorer la __lisibilit√©__ ce qui est indispensable pour
rendre la d√©marche intelligible par d'autres mais aussi pour soi, lorsqu'on
reprend un code √©crit il y a quelques temps ;
- Limiter la __redondance__ ce qui permet de simplifier
un code (paradigme du _don't repeat yourself_) ;
- Limite les risques d‚Äô__erreurs li√©es aux copier/coller__

## Avantages des fonctions

Les fonctions ont de nombreux avantages par rapport √† de longs
scripts :

- Limite les risques d'erreurs li√©s aux copier/coller
- Rend le code plus lisible et plus compact
- Un seul endroit du code √† modifier lorsqu'on souhaite modifier le traitement
- Facilite la r√©utilisation et la documentation du code !

::: {.callout-important}
## R√®gle d'or

Il faut utiliser une [**fonction**]{.red2} d√®s qu'on utilise une m√™me
portion de code plus de deux fois ([**_don't repeat yourself_ (DRY)**]{.red2})
:::


::: {.callout-tip}
## R√®gles pour √©crire des fonctions **pertinentes**

- Une t√¢che = une fonction
- Une t√¢che complexe = un encha√Ænement de fonctions r√©alisant chacune une t√¢che simple
- Limiter l'utilisation de variables globales

:::

En ce qui concerne l'installation des packages, nous allons voir
dans les parties [Structure de code](/chapters/projects-architecture.html) et [Portabilit√©](/chapters/portability.qmd)
qu'il ne faut pas
g√©rer ceci dans le script mais dans un √©l√©ment √† part, relatif √† l'environnement
d'ex√©cution du projet[^environnement]. De m√™me, ces parties pr√©senteront
des conseils pratiques sur la gestion des jetons d'acc√®s √† des API ou bases de donn√©es
qui ne __doivent jamais √™tre inscrites dans un code__.

[^environnement]: Nous pr√©senterons les deux approches principales en `Python`,
        leurs points commun et les points par lesquels ils diff√®rent :
        les environnements virtuels (g√©r√©s par un fichier `requirements.txt`)
        et les environnements conda (g√©r√©s par un fichier `environment.yml`)


Les scripts trop longs ne sont pas une bonne pratique. Il est pr√©f√©rable
de diviser l'ensemble des scripts ex√©cutant une
cha√Æne de production en _"monades"_, c'est-√†-dire en petites unit√©s
coh√©rentes. Les fonctions sont un outil privil√©gi√© pour cela
(en plus de limiter la redondance, et d'√™tre un outil privil√©gi√©
pour documenter un code).


::: {.callout-caution collapse="true"}
## Exemple: privil√©gier les _list comprehensions_

En `Python`, il est recommand√© de privil√©gier
les _list comprehensions_ √† l'utilisation de boucles
`for` indent√©es. Ces derni√®res sont en g√©n√©ral moins
efficaces et surtout impliquent un nombre important de
ligne de codes l√† o√π les compr√©hensions de listes sont
beaucoup plus concises

```python
liste_nombres = range(10)

# tr√®s mauvais
y = []
for x in liste_nombres:
    if x % 2 == 0:
        y.append(x*x)

# mieux
y = [x*x for x in liste_nombres if x % 2 == 0]
```


:::


### Conseils pour la programmation

Dans le monde de la programmation en `Python`, il existe deux paradigmes
diff√©rents :

* La __programmation fonctionnelle__ est une approche qui construit un
code en encha√Ænant des fonctions, c'est-√†-dire des op√©rations plus ou
moins standardis√©es ;
* La __programmation orient√©e objet (POO)__ consiste
√† construire son code en d√©finissant des objets
d'une certaine _classe_ ayant des
_attributs_ (les caract√©ristiques intrins√®ques de l'objet)
et sur lequel on effectue des op√©rations _ad hoc_ par le biais
de _m√©thodes_ qui encapsulent des op√©rations propres √†
chaque classe.


<details>

<summary>
Exemple de comparaison des deux paradigmes
</summary>

Merci _ChatGPT_ pour l'exemple :

```{python}
#| eval: true
class AverageCalculator:
    def __init__(self, numbers):
        self.numbers = numbers

    def calculate_average(self):
        return sum(self.numbers) / len(self.numbers)

# Utilisation
calculator = AverageCalculator([1, 2, 3, 4, 5])
print("Moyenne (POO):", calculator.calculate_average())

def calculate_average(numbers):
    return sum(numbers) / len(numbers)

# Utilisation
numbers = [1, 2, 3, 4, 5]
print("Moyenne (PF):", calculate_average(numbers))
```

</details>

La programmation fonctionnelle est plus intuitive que la
POO et permet souvent de d√©velopper du code plus
rapidement. La POO est une approche plus formaliste.
Celle-ci est int√©ressante lorsqu'une fonction doit
s'adapter au type d'objet en entr√©e (par exemple aller chercher des
poids diff√©rents selon le type de mod√®le [`Pytorch`](https://pytorch.org/vision/0.9/models.html)).
Cela √©vite les codes _spaghetti_ üçù inutilement complexes qui sont impossibles √† d√©bugger.

N√©anmoins, il convient d'√™tre pragmatique. La programmation orient√©e objet peut √™tre
plus complexe √† mettre en ≈ìuvre que la programmation fonctionnelle. Dans de
nombreuses situations, cette derni√®re, si elle est bien faite, suffit largement.
Il est utile lorsqu'on d√©veloppe dans le cadre d'un projet important d'adopter
une approche dite de __programmation d√©fensive__. Il s'agit d'un principe
de pr√©caution dans le paradigme de la programmation fonctionnelle qui vise
√† limiter les
situations impr√©vues en √©tant capable
de g√©rer, par exemple, un argument d'une fonction inattendu ou un objet
√† la structure diff√©rente de celle pour lequel le code a √©t√© pens√©.

::: {.callout-note}

## Le code spaghetti

Le code `spaghetti` est un style d'√©criture qui favorise l'apparition du syndrome du plat de spaghettis :
un code impossible √† d√©m√™ler parce qu'il fait un usage excessif de conditions, d'exceptions en tous sens, de gestion des √©v√©nements complexes. Il devient quasi impossible de savoir quelles ont √©t√© les conditions √† l'origine de telle ou telle erreur sans ex√©cuter ligne √† ligne (et celles-ci sont excessivement nombreuses du fait de mauvaises pratiques de programmation) le programme.

En fait, la programmation spaghetti qualifie tout ce qui ne permet pas de d√©terminer le qui, le quoi et le comment. Le code est donc plus long √† mettre √† jour car cela n√©cessite de remonter un √† un le fil des renvois.

:::

::: {.callout-tip collapse="true"}

## Un exemple progressif pour comprendre

üí° Supposons qu'on dispose d'une table de donn√©es qui utilise le code `‚àí99` pour repr√©senter les valeurs manquantes.
On d√©sire remplacer l'ensemble des `‚àí99` par des `NA`.

Voici un code `Python` qui permet de se placer dans ce cas qui, malheureusement,
arrive fr√©quemment.

```python
# On fixe la racine pour √™tre s√ªr de tous avoir le m√™me dataset
np.random.seed(1234)

# On cr√©√© un dataframe
a = np.random.randint(1, 10, size = (5,6))
df = np.insert(
    a,
    np.random.choice(len(a), size=6),
    -99,
)
df = pd.DataFrame(df.reshape((6,6)), columns=[chr(x) for x in range(97, 103)])
```


Un premier jet de code pourrait prendre la forme suivante :

```python
# Dupliquer les donn√©es
df2 = df.copy()
# Remplacer les -99 par des NA
df2.loc[df2['a'] == -99,'a'] = np.nan
df2.loc[df2['b'] == -99,'b'] = np.nan
df2.loc[df2['c'] == -99,'c'] = np.nan
df2.loc[df2['d'] == -99,'d'] = np.nan
df2.loc[df2['e'] == -98,'e'] = np.nan
df2.loc[df2['f'] == -99,'e'] = np.nan
```

Quelles sont les choses qui vous d√©rangent dans le code ci-dessus ?

<details>
<summary>
Indice üí° Regardez pr√©cis√©ment le code et le `DataFrame`, notamment les colonnes `e` et `g`.
</summary>
Il y a deux erreurs, difficiles √† d√©tecter:

- `df2.loc[df2['e'] == -98,'e'] = np.nan`: une erreur de copier-coller sur la valeur de l'erreur ;
- `df2.loc[df2['f'] == -99,'e'] = np.nan`: une erreur de copier-coller sur les colonnes en question
</details>

On peut noter au moins deux trois :

* Le code est long et r√©p√©titif, ce qui nuit √† sa lisibilit√© ;
* Le code est tr√®s d√©pendant de la structure des donn√©es (nom et nombre de colonnes) et doit √™tre adapt√© d√®s que celle-ci √©volue ;
* On a introduit des erreurs humaines dans le code, difficiles √† d√©tecter.

On voit dans la premi√®re version de notre code qu'il y a une structure commune √† toutes nos lignes de la forme `.[. == -99] = np.nan`. Cette structure va servir de base √† notre fonction, en vue de g√©n√©raliser le traitement que nous voulons faire.

```python
def fix_missing(x: pd.Series):
    x[x == -99] = np.nan
    return x

df2 = df.copy()
df2['a'] = fix_missing(df['a'])
df2['b'] = fix_missing(df['b'])
df2['c'] = fix_missing(df['c'])
df2['d'] = fix_missing(df['d'])
df2['e'] = fix_missing(df['e'])
df2['f'] = fix_missing(df['f'])
```

Cette seconde version du code est meilleure que la premi√®re version, car on a r√©gl√© le probl√®me d'erreur humaine (il n'est plus possible de taper `-98` au lieu de `-99`).

<details>
<summary>
Mais voyez-vous le probl√®me qui persiste ?
</summary>

Le code reste long et r√©p√©titif, et n'√©limine pas encore toute possibilit√© d'erreur, car il est toujours possible de se tromper dans le nom des variables.
</details>

La prochaine √©tape consiste √† √©liminer ce risque d'erreur en combinant deux fonctions (ce qu'on appelle la combinaison de fonctions).

La premi√®re fonction `fix_missing()` sert √† r√©gler le probl√®me sur un vecteur. La seconde g√©n√©ralisera ce proc√©d√© √† toutes les colonnes. Comme `Pandas` permet une approche vectorielle, il est fr√©quent de construire des fonctions sur des vecteurs et les appliquer ensuite √† plusieurs colonnes.


```python
def fix_missing(x: pd.Series):
    x[x == -99] = np.nan
    return x

df2 = df.copy()
df2 = df2.apply(fix_missing)
```

Cette troisi√®me version du code a plusieurs avantages sur les deux autres versions :

1. Elle est plus concise et plus lisible ;
2. Si on a un changement de code pour les valeurs manquantes, il suffit de le mettre √† un seul endroit ;
3. Elle fonctionne quel que soit le nombre de colonnes et le nom des colonnes ;
4. On ne peut pas traiter une colonne diff√©remment des autres par erreur.

De plus, le code est facilement g√©n√©ralisable.

Par exemple, √† partir de la m√™me structure, √©crire le code qui permet de ne traiter que les colonnes *a*,*b* et *e*
ne demande pas beaucoup d'√©nergie.


```python
df2 = df.copy()
df2[['a','b','e']] = df2[['a','b','e']].apply(fix_missing)
```
:::

Un certain nombre de conseils sont pr√©sents dans le [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/style/)
qui vise √† faire conna√Ætre les pr√©ceptes du _"Zen of Python"_ (PEP 20).
[Ce post de blog](https://towardsdatascience.com/the-zen-of-python-a-guide-to-pythons-design-principles-93f3f76d088a) illustre quelques uns
de ces principes avec des exemples.

::: {.callout-note collapse="true"}
## Le _Zen de Python_

Le _"Zen de Python"_ est une collection de principes pour la programmation en `Python`, √©crite par Tim Peters en 2004
sous la forme d'aphorismes. Ceux-ci
mettent en lumi√®re la philosophie de conception du langage `Python`.

Vous pouvez retrouver ces conseils dans `Python` en
tapant le code suivant:

:::: {.python}

```python
import this
```

```
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

::::

:::



# Principe 3Ô∏è‚É£ : (auto)documenter son code

Un code √©crit avec des __noms de variables et de fonctions explicites__ est autant,
voire plus, informatif que les commentaires qui l‚Äôaccompagnent.
C‚Äôest pourquoi il est essentiel de respecter des conventions, et de s'y tenir,
pour le
choix des noms des objets afin d‚Äôassurer la lisibilit√© des programmes.

Il est recommand√© de privil√©gier l'__autodocumentation__
√† la multiplication de commentaires dans un document. Trop de commentaires fait que
ceux-ci ne seront
jamais lus. Ils risquent d'ailleurs de ne pas √™tre actualis√©s en m√™me temps que le code
qu'ils accompagnent, ce qui est une source d'erreur potentielle.
Une documentation est inutile si elle d√©crit ce qui est intelligible
par ailleurs en lisant le code : il est donc important
de documenter le pourquoi plut√¥t que le comment.

En r√©sum√©,
les deux grands principes de la documentation au sein d'un script sont les suivants :

- Il est pr√©f√©rable de __documenter le pourquoi plut√¥t que le comment__. Le _"comment"_ devrait
√™tre compr√©hensible √† la lecture du code ;
- Privil√©gier l'autodocumentation via des __nommages pertinents__.


::: {.callout-tip}
## Comment bien documenter un script ?

- **Minimum** üö¶ : commentaire au d√©but du script pour d√©crire ce qu'il fait
- **Bien** üëç : commenter les parties "d√©licates" du code
- **Id√©al** üí™ : documenter ses fonctions avec la syntaxe des `docstrings`.

:::


::: {.callout-tip collapse="true"}
## Le _type hinting_, un √©l√©ment d'autodocumentation

`Python` propose une fonctionalit√© assez plaisante qui est
le _`type hinting`_
([doc officielle](https://docs.python.org/3/library/typing.html)
et [tutoriel sur realpython.com](https://realpython.com/lessons/type-hinting/)).

Cette approche permet d'indiquer le type d'argument attendu par une fonction
et celui qui sera renvoy√© par la fonction.
Par exemple, la personne ayant √©crit la fonction suivante

```python
def calcul_moyenne(df: pd.DataFrame, col : str = "y") -> pd.DataFrame:
    return df[col].mean()
```

propose d'utiliser deux types d'inputs (un `DataFrame Pandas` et une chaine de caract√®re)
et indique qu'elle renverra un `DataFrame Pandas`.
A noter que c'est indicatif, non contraignant.
En effet, le code ci-dessus fonctionnera si on fournit en argument `col` une liste puisque `Pandas` sait g√©rer cela √† l'√©tape `df[col].mean()`.

Le _type hinting_ est un √©l√©ment d'autodocumentation puisque gr√¢ce √† ces _hints_ le code
suffit √† faire comprendre la volont√© de la personne l'ayant √©crit.
:::


La documentation vise √† pr√©senter la d√©marche g√©n√©rale, √©ventuellement
√† travers des exemples, mais aussi √† expliciter certains √©l√©ments
du code (une op√©ration qui n'est pas √©vidente, des arguments de fonction, etc.).
La documentation se m√©lange donc aux instructions visant √† √™tre ex√©cut√©es
mais s'en distingue. Ces principes sont h√©rit√©s du paradigme de la
**"programmation lettr√©e"** (_Literate programming_) dont l'un des
avocats √©tait Donald Knuth.


> _"Je crois que le temps est venu pour une am√©lioration significative de la documentation des programmes, et que le meilleur moyen d'y arriver est de consid√©rer les programmes comme des ≈ìuvres litt√©raires. D'o√π mon titre, ¬´ programmation lettr√©e ¬ª._
>
> _Nous devons changer notre attitude traditionnelle envers la construction des programmes : au lieu de consid√©rer que notre t√¢che principale est de dire √† un ordinateur ce qu'il doit faire, appliquons-nous plut√¥t √† expliquer √† des √™tres humains ce que nous voulons que l'ordinateur fasse._
>
> _Celui qui pratique la programmation lettr√©e peut √™tre vu comme un essayiste, qui s'attache principalement √† exposer son sujet dans un style visant √† l'excellence. Tel un auteur, il choisit , avec soin, le dictionnaire √† la main, les noms de ses variables et en explique la signification pour chacune d'elles. Il cherche donc √† obtenir un programme compr√©hensible parce que ses concepts sont pr√©sent√©s dans le meilleur ordre possible. Pour cela, il utilise un m√©lange de m√©thodes formelles et informelles qui se compl√®tent"_
>
> Donald Knuth, _Literate Programming_ ([source](https://fr.wikipedia.org/wiki/Programmation_lettr%C3%A9e))

Cela peut amener √† distinguer deux types de documentation :

1. Une documentation g√©n√©rale de type `Jupyter Notebook` ou `Quarto Markdown` qui
pr√©sente certes du code ex√©cut√© mais dont l'objet principal est de pr√©senter
une d√©marche ou des r√©sultats ;
2. Une documentation de la d√©marche plus proche du code dont l'un des
exemples sont les _docstrings_ `Python` (ou son √©quivalent `R`, la documentation `Roxygen`).

:::


:::: {.content-visible when-profile="en"}

# Principle 2Ô∏è‚É£: Favour a Modular Structure

## Objectives

- Encourage __conciseness__ to reduce the risk of error and make the process clearer;
- Improve __readability__, which is essential to make the process understandable by others but also for yourself when revisiting an old script;
- Reduce __redundancy__, which simplifies code (the _don't repeat yourself_ paradigm);
- Minimize the risk of __errors due to copy/paste__.

## Advantages of Functions

Functions have many advantages over long scripts:

- Limit the risk of errors caused by copy/paste;
- Make the code more readable and compact;
- Only one place to modify the code if the processing changes;
- Facilitate code reuse and documentation!

::: {.callout-important}
## Golden Rule

You should use a [**function**]{.red2} whenever a piece of code is used more than twice ([**_don't repeat yourself_ (DRY)**]{.red2}).
:::

::: {.callout-tip}
## Rules for Writing **Effective** Functions

- One task = one function;
- A complex task = a sequence of functions, each performing a simple task;
- Limit the use of global variables.

:::

Regarding package installation, as we will see in the [Project Structure](/chapters/projects-architecture.html) and [Portability](/chapters/portability.qmd) sections, this should not be managed inside the script, but in a separate element related to the project's execution environment[^environnement]. Those sections also provide practical advice on handling API or database tokens, which __should never be written in the code__.

[^environnement]: We will present the two main approaches in `Python`, their similarities and differences: virtual environments (managed by a `requirements.txt` file) and conda environments (managed by an `environment.yml` file).

Overly long scripts are not a best practice. It is better to divide all scripts executing a production chain into _"monads"_, i.e., small coherent units. Functions are a key tool for this purpose (they help reduce redundancy and are a preferred tool for documenting code).

::: {.callout-caution collapse="true"}
## Example: Prefer List Comprehensions

In `Python`, it is recommended to prefer list comprehensions over indented `for` loops. The latter are generally less efficient and involve a larger number of code lines, whereas list comprehensions are much more concise:

```python
liste_nombres = range(10)

# very bad
y = []
for x in liste_nombres:
    if x % 2 == 0:
        y.append(x*x)

# better
y = [x*x for x in liste_nombres if x % 2 == 0]
```

:::

### Programming Advice

In the Python programming world, there are two main paradigms:

- __Functional programming__: builds code by chaining functions, i.e., more or less standardized operations;
- __Object-Oriented Programming (OOP)__: builds code by defining objects of a given _class_ with _attributes_ (intrinsic features) and custom _methods_ to perform class-specific operations.

<details>
<summary>
Example comparing the two paradigms
</summary>

Thanks _ChatGPT_ for the example:

```{python}
#| eval: true
class AverageCalculator:
    def __init__(self, numbers):
        self.numbers = numbers

    def calculate_average(self):
        return sum(self.numbers) / len(self.numbers)

# Usage
calculator = AverageCalculator([1, 2, 3, 4, 5])
print("Average (OOP):", calculator.calculate_average())

def calculate_average(numbers):
    return sum(numbers) / len(numbers)

# Usage
numbers = [1, 2, 3, 4, 5]
print("Average (FP):", calculate_average(numbers))
```

</details>

Functional programming is more intuitive than OOP and often allows for quicker code development. OOP is a more formalist approach, useful when functions need to adapt to the input object type (e.g., loading different model weights depending on the model type in [`Pytorch`](https://pytorch.org/vision/0.9/models.html)). It avoids üçù _spaghetti code_ that‚Äôs hard to debug.

However, one should remain pragmatic. OOP can be more complex to implement than functional programming. In many cases, well-written functional code is sufficient. For large projects, adopting a __defensive programming__ approach is helpful ‚Äî a precautionary strategy in the functional paradigm that anticipates and manages unexpected situations (e.g., wrong argument type or structure).

::: {.callout-note}

## Spaghetti Code

‚ÄúSpaghetti code‚Äù refers to programming style that leads to tangled code due to excessive use of conditions, exceptions, and complex event handling. It becomes almost impossible to trace the cause of errors without stepping through every line of code ‚Äî and there are many, due to poor practices.

Spaghetti code prevents determining who, what, and how something happens, making updates time-consuming since one must follow the chain of references line by line.

:::

::: {.callout-tip collapse="true"}
## A Progressive Example

üí° Suppose we have a dataset that uses `‚àí99` to represent missing values. We want to replace all `‚àí99` with `NA`.

```python
np.random.seed(1234)
a = np.random.randint(1, 10, size = (5,6))
df = np.insert(
    a,
    np.random.choice(len(a), size=6),
    -99,
)
df = pd.DataFrame(df.reshape((6,6)), columns=[chr(x) for x in range(97, 103)])
```

First attempt:

```python
df2 = df.copy()
df2.loc[df2['a'] == -99,'a'] = np.nan
df2.loc[df2['b'] == -99,'b'] = np.nan
df2.loc[df2['c'] == -99,'c'] = np.nan
df2.loc[df2['d'] == -99,'d'] = np.nan
df2.loc[df2['e'] == -98,'e'] = np.nan
df2.loc[df2['f'] == -99,'e'] = np.nan
```

What‚Äôs wrong here?

<details>
<summary>
Hint üí° Look at columns `e` and `g`.
</summary>
Two copy-paste errors:
- `-98` instead of `-99`;
- `'e'` instead of `'f'` in the last line.
</details>

Next improvement ‚Äî using a function:

```python
def fix_missing(x: pd.Series):
    x[x == -99] = np.nan
    return x

df2 = df.copy()
df2['a'] = fix_missing(df['a'])
df2['b'] = fix_missing(df['b'])
...
```

Still repetitive and error-prone with column names.

Best version ‚Äî apply function across all columns:

```python
df2 = df.copy()
df2 = df2.apply(fix_missing)
```

Now the code is:
1. Concise;
2. Robust to data structure changes;
3. Free from hard-coded mistakes;
4. Easily generalizable ‚Äî e.g., apply only on selected columns:

```python
df2[['a','b','e']] = df2[['a','b','e']].apply(fix_missing)
```

:::

Resources like the [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/style/) and [this blog post](https://towardsdatascience.com/the-zen-of-python-a-guide-to-pythons-design-principles-93f3f76d088a) illustrate these design principles well.

::: {.callout-note collapse="true"}
## The Zen of Python

Written by Tim Peters in 2004, this set of aphorisms embodies Python‚Äôs design philosophy:

```python
import this
```

```
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
...
Namespaces are one honking great idea -- let's do more of those!
```

:::

::::