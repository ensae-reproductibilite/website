---
title: "YAML 101"
image: /penguin.png
description: |
  Introduction à l'utilisation de `YAML`, un langage devenu incontournable dans l'éco-système DevOps pour sa capacité à produire des fichiers de configuration déclarative lisibles et expressifs.
order: 7.5
href: chapters/yaml101.html
---

## Qu'est-ce que le format `YAML` ?

`YAML` est un acronyme récursif signifiant [*YAML Ain't Markup Language*](https://yaml.org/). `YAML` est un langage de sérialisation de données au format texte : il permet de structurer de la donnée dans des fichiers textuels, à l'instar d'autres formats populaires (`CSV`, `JSON`, `XML`, etc.). Sa spécificité est qu'il est conçu pour être à la fois expressif et facile à lire pour un humain. Expressif dans la mesure où il permet de représenter de l'information hiérarchique, ce que ne permet pas le format `CSV` par exemple qui représente essentiellement des données tabulaires ("fichier plat"). Lisible car, contrairement aux languages dont la structure est basée sur des balises (*markup*) comme `XML` ou bien délimitée par des symboles comme l'accolade en `JSON`, `YAML` se démarque par une syntaxe basée sur l'indentation — comme `Python`. 

Voici un exemple typique d'un fichier `YAML`, qui compare les principaux langages utilisés pour représenter des données hiérarchiques dans un format textuel[^source].

[^source]: L'exemple présenté est inspiré de [ce tutoriel](https://www.ambient-it.net/tout-savoir-fichiers-yaml/).

```yaml
---
type: tutorial
domain:
  - devops
language:
  - yaml:
      name: YAML Ain't Markup Language
      born: 2001
      legibility: awesome
  - json:
      name: JavaScript Object Notation
      born: 2001
      legibility: good
  - xml:
      name: Extensible Markup Language
      born: 1996
      legibility: bad
---
```

## `YAML` et l'approche `GitOps` ?

Grâce à cette lisibilité, le langage `YAML` est rapidement devenu un standard dans les éco-systèmes `DevOps` et `MLOps` dans la mesure où il facilite grandement l'interaction entre les humains et les systèmes automatisés. En particulier, il est devenu un élément central des environnements de déploiement modernes basés sur une approche dite **déclarative**[^sql]. Au lieu de spécifier étape par étape comment déployer une ressource (approche **impérative**), `YAML` permet de décrire simplement **l'état final souhaité** de l'environnement. C'est alors l'outil utilisé (par exemple, `Kubernetes` dans l'exemple ci-dessous) qui gère les détails d'implémentation de manière la plus adaptée. On parle également d'approche ***Infrastructure as Code*** : l'infrastructure peut être complètement décrite dans des fichiers de configuration `YAML` — qu'on appelle **manifestes** — qui permettent de décrire l'état souhaité de celle-ci. Cette manière de spécifier les environnements favorise la **reproductibilité**, chaque état de l'infrastructure étant clairement décrit et pouvant être reproduit simplement.

[^sql]: A titre d'analogie, l'approche déclarative est également au cœur du langage `SQL`. En `SQL`, on décrit le traitement souhaité dans un langage proche du langage naturel (*SELECT* ce groupe de variables, *FILTER* ces individus, etc.) et c'est le moteur d'exécution sous-jacent qui choisit comment effectuer les calculs demandés de manière optimale. C'est notamment une des raisons de la popularité du langage `SQL` dans l'éco-système *big data* : il est possible d'appliquer une même requête à des données de volumétries très différentes dans la mesure où le moteur d'exécution sous-jacent va convertir la requête de manière appropriée. Par exemple, une requête `SQL` sera convertie par `Spark` en opérations `MapReduce` distribuées permettant de traiter des volumes considérables de données (voir chapitre [*big data*](/chapters/big-data.html) pour plus de détails).

Bien entendu, ces fichiers décrivant les environnements souhaités ont vocation à être versionnés sur un dépôt `Git`. Cette extension directe de l'approche *Infrastructure as Code* se nomme le ***GitOps*** : l'architecture est décrite sous forme de manifestes (`YAML`) et ces manifestes sont versionnés sur un dépôt `Git` qui devient ainsi la **source de vérité unique** de spécification de l'environnement[^git]. Cette approche favorise à la fois la **traçabilité** — tout changement est documenté dans l'historique du dépôt `Git` — et l'automatisation — l'infrastructure peut être déployée automatiquement à partir du dépôt `Git` grâce à des outils de déploiement continus orientés ***GitOps*** comme `ArgoCD` (cf. chapitre [déploiement](/chapters/deployment.html)). 

Voici un exemple illustrant ce concept dans le contexte de `Kubernetes`. 

```yaml
kind: Pod
metadata:
  name: my-api-pod
spec:
  containers:
    - name: api
      image: my_dh_account/my_fast_api:0.0.1
      env:
        - name: MODEL
          value: random_forest
```

## `YAML` vs. JSON

Une caractéristique notable du `YAML` est qu'il s'agit d'un **superset de JSON**. Cela signifie que tout document JSON valide est également un document `YAML` valide. La différence principale réside dans la syntaxe et la lisibilité :

- `YAML` utilise l'indentation pour structurer les données, augmentant sa lisibilité.
- JSON utilise des accolades pour structurer ses objets, ce qui peut réduire sa lisibilité mais le rend moins susceptible aux erreurs d'indentation.

Comparaison `YAML` vs JSON :

```yaml
user:
  name: Alice
  age: 30
```

Correspondance exacte en JSON :

```json
{
  "user": {
    "name": "Alice",
    "age": 30
  }
}
```

Plusieurs outils en ligne, comme [`YAML`-to-json](https://jsonformatter.org/`YAML`-to-json) et [json-to-`YAML`](https://jsonformatter.org/json-to-`YAML`), permettent de convertir facilement ces formats entre eux.

## Caractéristiques d'un fichier `YAML`

Les fichiers `YAML` portent généralement les extensions `.`YAML`` ou `.yml`. Leur contenu est organisé de façon hiérarchique par des paires clé-valeur, structurées par indentation.

Les types de données supportés par `YAML` sont variés :

- **Chaînes de caractères** : entourées ou non de guillemets (exemple : `"hello"`).
- **Numériques** : entiers ou flottants (exemple : `42`, `3.14`).
- **Booléens** : représentés par `true` ou `false`.
- **Listes** : éléments précédés d'un tiret (`-`).
- **Dictionnaires (maps)** : collections structurées de paires clé-valeur.

Exemple concret illustrant ces types de données :

```yaml
kind: Pod
metadata:
  name: my-api-pod
spec:
  containers:
    - name: api
      image: my_dh_account/my_fast_api:0.0.1
      env:
        - name: MODEL
          value: deepseek-ai/DeepSeek-R1
        - name: DEBUG
          value: true
      ports:
        - containerPort: 8000
```

## Validation et erreurs fréquentes

Le principal point de vigilance lorsqu'on écrit en `YAML` concerne l'indentation. Celle-ci est essentielle à la structuration des données. L'indentation recommandée est de **deux espaces**, jamais des tabulations, qui peuvent générer des erreurs d'interprétation.

Pour prévenir ces erreurs, de nombreux outils de validation existent :

- **Support natif dans les IDE** : VSCode, IntelliJ, PyCharm offrent des extensions qui détectent immédiatement les erreurs d'indentation ou de syntaxe.
- ***Linters* dédiés** : [YAMLlint](https://yamllint.com) permet une validation précise et rapide.

## Conclusion

La maîtrise de `YAML` est aujourd'hui indispensable pour tout data scientist impliqué dans des projets nécessitant de la portabilité et du déploiement automatisé. Sa simplicité apparente et sa puissance sous-jacente en font un choix naturel dans les approches modernes de mise en production, notamment via Kubernetes, Docker, et les méthodologies GitOps.

