---
title: "Am√©liorer la qualit√© de son code"
---


# Introduction

## L'enjeu d'un code lisible et maintenable

> _"The code is read much more often than it is written."_
>
> Guido Van Rossum[^1]

[^1]: Guido Van Rossum est le cr√©ateur de `Python`, c'est donc quelqu'un qu'il est pertinent d'√©couter.

Lorsque l'on s'initie √† la pratique de la *data science*, il est assez naturel de voir le code d'une mani√®re tr√®s fonctionnelle : je veux r√©aliser une t√¢che donn√©e ‚Äî par exemple un algorithme de classification ‚Äî et je vais donc assembler dans un *notebook* des bouts de code, souvent trouv√©s sur internet, jusqu'√† obtenir un projet qui r√©alise la t√¢che voulue. La structure du projet importe assez peu, tant qu'elle permet d'importer correctement les donn√©es n√©cessaires √† la t√¢che en question.

Si cette approche flexible et minimaliste fonctionne tr√®s bien lors de la phase d'apprentissage, il est malgr√© tout indispensable de s'en d√©tacher progressivement √† mesure que l'on progresse et que l'on peut √™tre amen√© √† r√©aliser des projets plus professionnels ou bien √† int√©grer des projets collaboratifs.

En particulier, il est important de proposer, parmi les multiples mani√®res de r√©soudre un probl√®me informatique, une solution qui soit intelligible par d'autres personnes parlant le langage. Le code est en effet lu bien plus souvent qu'il n'est √©crit, c'est donc avant tout un __outil de communication__. De m√™me, la maintenance d'un code demande g√©n√©ralement beaucoup plus de moyens que sa phase de d√©veloppement initial, il est donc important de penser en amont la qualit√© de son code et la structure de son projet de sorte √† le rendre au maximum maintenable dans le temps.

Afin de faciliter la communication et r√©duire la douleur d'avoir √† faire √©voluer un code obscur, des tentatives plus ou moins institutionnalis√©es de d√©finir des conventions ont √©merg√©. Ces conventions d√©pendent naturellement du langage utilis√©, mais les principes sous-jacents s'appliquent de mani√®re universelle √† tout projet bas√© sur du code.


## De l'importance de suivre les conventions

`Python` est un langage tr√®s lisible.
Avec un peu d‚Äôeffort sur le nom des objets,
sur la gestion des d√©pendances et sur la structure du programme,
on peut tr√®s bien comprendre un script sans avoir besoin de l‚Äôex√©cuter.
C'est l'une des principales forces du langage `Python` qui permet ainsi
une acquisition rapide des bases et facilite l'appropriation d'un script.

La communaut√© `Python` a abouti √† un certain nombre de normes,
dites `PEP` (_Python Enhancement Proposal_),
qui constituent un standard dans l‚Äô√©cosyst√®me Python.
Les deux normes les plus connues sont :

- la norme [`PEP8`](https://peps.python.org/pep-0008/) qui d√©finit un certain nombre de conventions
relatives au code
- la norme [`PEP257`](https://peps.python.org/pep-0257/) consacr√©e √† la documentation (_docstrings_).

::: {.callout-note}
Dans l'univers `R`, la formalisation
a √©t√© moins organis√©e. Ce langage est plus permissif que `Python`
sur certains aspects[^2].
N√©anmoins, des standards ont √©merg√©, √† travers
un certain nombre de _style guides_ dont les plus connus
sont le
[_tidyverse style guide_](https://style.tidyverse.org/googl) et le
[_google style guide_](https://google.github.io/styleguide/Rguide.html)[^3]
(voir [ce post](https://blog.r-hub.io/2022/03/21/code-style/) qui pointe vers
un certain nombre de ressources sur le sujet).
:::

[^2]: Par exemple, en `R`, il est possible d'utiliser `<-` ou `=`
pour l'assignation,
on ne recontre pas d'erreur en cas de mauvaise indentation...

[^3]: Il existe d'autres guides de style notamment le [MLR style guide](https://github.com/mlr-org/mlr3/wiki/Style-Guide#theoretical-style-guide)
qui est un _framework_ orient√© objet de _Machine Learning_ en `R`.


Ces conventions sont arbitraires, dans une certaine mesure.  Il est tout √† fait
possible de trouver certaines conventions moins esth√©tiques que d'autres. 

Ces conventions ne sont pas non plus immuables: les langages et leurs usages
√©voluent, ce qui n√©cessite de mettre √† jour les conventions. Cependant,
adopter dans la mesure du possible certains des r√©flexes pr√©conis√©s par ces
conventions devrait am√©liorer la capacit√© √† √™tre compris par la communaut√©,
augmenter les chances de 
b√©n√©ficier d'apport de celle-ci pour adapter le code mais aussi r√©duire la 
difficult√© √† faire √©voluer un code.

Il existe beaucoup de philosophies diff√©rentes sur le style de codage et,
en fait, le plus important est
la __coh√©rence__ :
si on choisit une convention, par exemple _snake case_ plut√¥t que
_camel case_, le mieux est de s'y tenir. 


Les conventions vont au-del√† de la syntaxe. Un certain nombre de standards
d'organisation d'un projet ont √©merg√©, qui seront abord√©es
dans le [prochain chapitre](/chapters/projects-architecture.html). 

# Comment adopter ces bonnes pratiques ?

Les √©l√©ments expos√©s dans ce chapitre ne sont pas exhaustifs.
Ils visent √† pointer vers quelques probl√©matiques prioritaires tout en proposant des conseils pratiques.
L'√©quivalent `R` de ce cours est propos√© sous la forme de formation √† l'Insee et 
est accessible depuis [ce lien](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/). 

Dans la lign√©e de la vision des bonnes pratiques comme continuum propos√©e en [introduction](/chapters/introduction.html), il n'est pas n√©cessairement souhaitable d'appliquer toutes les recommendations pr√©sent√©es dans ce chapitre √† chaque projet. Nous recommandons de les voir plut√¥t comme des bonnes habitudes √† acqu√©rir en op√©rant un va-et-vient r√©gulier entre la pratique et la th√©orie. Les outils
que nous allons proposer seront l√† pour acc√©l√©rer la mise en oeuvre des bonnes pratiques.

Il est √©galement assez instructif de regarder
le code modifi√© par les outils pour comprendre et corriger certains probl√®mes dans sa mani√®re de d√©velopper. 
Par exemple, √† la lecture de ce chapitre, vous allez certainement retenir en particulier certaines r√®gles qui tranchent avec vos pratiques actuelles. Vous pouvez alors essayer d'appliquer ces nouvelles r√®gles pendant un certain temps puis, lorsque celles-ci seront devenues naturelles, revenir √† ce guide et appliquer le processus √† nouveau. En proc√©dant ainsi de mani√®re incr√©mentale, vous am√©liorerez progressivement la qualit√© de vos projets sans avoir l'impression de passer trop de temps sur des micro-d√©tails, au d√©triment des objectifs globaux du projet.


# Principes g√©n√©raux


Les premi√®res conventions √† √©voquer ont trait √† la syntaxe du code et
ont les objectifs suivants, qui seront d√©taill√©s par la suite :

- [Am√©liorer la lisibilit√©](#lisibilite) ce qui est indispensable pour
rendre la d√©marche intelligible par d'autres mais aussi pour soi, lorsqu'on
reprend un code √©crit il y a quelques temps ;
- [Favoriser la concision](#concision) pour r√©duire le risque d'erreur
et rendre la d√©marche plus claire ;
- Suivre les r√®gles explicites ou les conventions d'un langage pour
[assurer le fonctionnement et la coh√©rence](#coherence) d'un code ;
- [Limiter la redondance](#redondance) ce qui permet de simplifier
un code (paradigme du _don't repeat yourself_) ;
- [Documenter un code](#documentation) ce qui facilite son acquisition
par d'autres (√† condition de ne pas aller dans l'exc√®s de documentation).


## Lisibilit√©  {#lisibilite}

Un code √©crit avec des noms de variables et de fonctions explicites est autant,
voire plus, informatif que les commentaires qui l‚Äôaccompagnent[^autodoc].
C‚Äôest pourquoi il est essentiel de respecter des conventions pour le
choix des noms des objets afin d‚Äôassurer la lisibilit√© des programmes.

[^autodoc]: Nous allons d'ailleurs plut√¥t recommander l'__autodocumentation__
        que la multiplication de commentaires dans un document qui ne seront
        jamais lus ou qui ne seront pas actualis√©s en m√™me temps que le code
        qu'ils accompagnent. 

Un certain nombre de conseils sont pr√©sents dans le [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/style/)
qui vise √† faire conna√Ætre les pr√©ceptes du _"Zen of Python"_ (PEP 20).
[Ce post de blog](https://towardsdatascience.com/the-zen-of-python-a-guide-to-pythons-design-principles-93f3f76d088a) illustre quelques uns
de ces principes avec des exemples.
Vous pouvez retrouver ces conseils dans `Python` en 
tapant le code suivant:

```python
import this
```

```
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

Il est conseill√©
de suivre ces deux principes lorsqu'on commence √† programmer
des fonctions (ce qui, comme cela est √©voqu√© par la suite, est
toujours recommand√©).

- Faire attention au type d'objet renvoy√© par `Python`.
Ce langage ne propose pas de typage
fort,
il est donc possible qu'une fonction renvoie des objets de nature diff√©rente
selon les cas[^if]. Cela peut amener √† des surprises lorsqu'on utilise une 
telle fonction dans un code. Il est recommand√© d'√©viter ce comportement
en proposant des fonctions diff√©rentes si l'_output_ d'une fonction
est de nature diff√©rente. Ce principe de pr√©caution (mais aussi d'information)
renvoie au paradigme de
la [programmation d√©fensive](https://en.wikipedia.org/wiki/Defensive_programming). 


[^if]: Par exemple, √† la suite d'une s√©rie de
        conditions `if` (selon les cas une liste, un vecteur,
        un `DataFrame`, etc.)

- Privil√©gier la programmation orient√©e objet lorsqu'une fonction doit
s'adapter au type d'objet en entr√©e (par exemple aller chercher des
√©l√©ments diff√©rents pour un objet `lm` ou un objet `glm`).
Cela √©vite les codes _spaghetti_ üçù inutilement complexes qui sont impossibles √† d√©bugger.


::: {.callout-tip}

## _Type hinting_

`Python` propose une fonctionalit√© assez plaisante qui est
le _`type hinting`_
([doc officielle](https://docs.python.org/3/library/typing.html)
et [tutoriel sur realpython.com](https://realpython.com/lessons/type-hinting/)).

Cette approche permet d'indiquer le type d'argument attendu par une fonction
et celui qui sera renvoy√© par la fonction.
Par exemple, la personne ayant √©crit la fonction suivante 

```python
def calcul_moyenne(df: pd.DataFrame, col : str = "y") -> pd.DataFrame:
    return df[col].mean()
```

propose d'utiliser deux types d'inputs (un `DataFrame Pandas` et une chaine de caract√®re)
et indique qu'elle renverra un `DataFrame Pandas`.
A noter que c'est indicatif, non contraignant.
En effet, le code ci-dessus fonctionnera si on fournit en argument `col` une liste puisque `Pandas` sait g√©rer cela √† l'√©tape `df[col].mean()`.

Le _type hinting_ est un √©l√©ment d'autodocumentation puisque gr√¢ce √† ces _hints_ le code
suffit √† faire comprendre la volont√© de la personne l'ayant √©crit. 
:::


::: {.callout-note}

## Le code spaghetti

Le code `spaghetti` est un style d'√©criture qui favorise l'apparition du syndrome du plat de spaghettis : 
un code impossible √† d√©m√©ler parce qu'il fait un usage excessif de conditions, d'exceptions en tous sens, de gestion des √©v√©nements complexes. Il devient quasi-impossible de savoir quelles ont √©t√© les conditions √† l'origine de telle ou telle erreur sans ex√©cuter ligne √† ligne (et celles-ci sont excessivement nombreuses du fait de mauvaises pratiques de programmation) le programme. 

En fait, la programmation spaghetti qualifie tout ce qui ne permet pas de d√©terminer le qui, le quoi et le comment. Le code est donc plus long √† mettre √† jour car cela n√©cessite de remonter un √† un le fil des renvois.

:::

## Concision  {#concision}


Un code reproductible doit pouvoir s'ex√©cuter de mani√®re lin√©aire.
S'il provoque une erreur, il est important de pouvoir identifier
l'instruction responsable pour pouvoir _debugger_.
Comme une d√©monstration math√©matique, un code intelligible 
doit viser la concision et la simplicit√©. Les codes tr√®s longs
sont souvent signes de r√©p√©titions et sont difficiles √† d√©bugger. 

Les scripts trop longs ne sont pas une bonne pratique. Il est pr√©f√©rable
de diviser l'ensemble des scripts ex√©cutant une
cha√Æne de production en _"monades"_, c'est-√†-dire en petites unit√©s
coh√©rentes. Les fonctions sont un outil privil√©gi√© pour cela
(en plus de limiter la redondance, et d'√™tre un outil privil√©gi√©
pour documenter un code).


::: {.callout-caution collapse="true"}
## Exemple: privil√©gier les _list comprehensions_

En `Python`, il est recommand√© de privil√©gier
les _list comprehensions_ √† l'utilisation de boucles
`for` indent√©es. Ces derni√®res sont en g√©n√©ral moins
efficaces et surtout impliquent un nombre important de 
ligne de codes l√† o√π les compr√©hensions de listes sont
beaucoup plus concises

```python
liste_nombres = range(10)

# tr√®s mauvais
y = []
for x in liste_nombres:
    if x % 2 == 0:
        y.append(x*x)

# mieux
y = [x*x for x in liste_nombres if x % 2 == 0]
```


:::

::: {.callout-important}
## R√®gle d'or

Il faut utiliser une [**fonction**]{.red2} d√®s qu'on utilise une m√™me
portion de code plus de deux fois ([**_don't repeat yourself_ (DRY)**]{.red2})
:::


Les fonctions ont de nombreux avantages par rapport √† de longs
scripts:

- Limite les risques d'erreurs li√©s aux copier/coller
- Rend le code plus lisible et plus compact
- Un seul endroit du code √† modifier lorsqu'on souhaite modifier le traitement
- Facilite la r√©utilisation et la documentation du code !

::: {.callout-tip}
## R√®gles pour √©crire des fonctions **pertinentes**

- Une t√¢che = une fonction
- Une t√¢che complexe = un encha√Ænement de fonctions r√©alisant chacune une t√¢che simple
- Limiter l'utilisation de variables globales.

:::


## Coh√©rence du script {#coherence}

Lister les d√©pendances est important: 

- pour des raisons techniques: le logiciel doit savoir o√π aller
chercher les fonctions utilis√©es dans un script pour avoir un code fonctionnel ;
- pour des raisons conventionnelles: les utilisateurs doivent comprendre les
d√©pendances √† installer pour √™tre en mesure de r√©utiliser le code. 

Les imports se mettent conventionnellement en d√©but de script,
qu'il s'agisse d'import de packages dans leur ensemble ou seulement de certaines fonctions:

```python
import pandas as pd
from sklearn.model_selection import cross_val_score
```

Dans le premier cas, on fait ensuite r√©f√©rence aux fonctions en les faisant 
pr√©c√©der du nom du package :

```python
pd.DataFrame([0,1])
```

Cela permet de dire √† `Python` d'aller chercher dans le _namespace_ `pd` (alias pour `pandas` qui est lui-m√™me un ensemble de scripts enregistr√©s sur le disque) la fonction `DataFrame`.


::: {.callout-tip collapse="true"}

## Quelques conseils compl√©mentaires. 

En premier lieu, il convient d'adopter
les m√™mes standards que la communaut√© pour les noms de package. 

```python
# bien
import numpy as np

# trompeur
import numpy as pd
```

Il faut √©galement
faire attention aux _namespaces_ pour √©viter les conflits entre fonctions.
Cela implique de ne pas importer l'ensemble des fonctions d'un package de
la mani√®re suivante:

```python
from numpy import *
from math import *
```

Dans ce cas, on va se retrouver avec des conflits potentiels entre les
fonctions du package `numpy` et du package `math` qui portent le m√™me
nom (`floor` par exemple). 

:::


En ce qui concerne l'installation des packages, nous allons voir
dans les parties [Structure de code](/chapters/projects-architecture.html) et [Portabilit√©](/chapters/portability.qmd)
qu'il ne faut pas
g√©rer ceci dans le script mais dans un √©l√©ment √† part, relatif √† l'environnement 
d'ex√©cution du projet[^environnement].

[^environnement]: Nous pr√©senterons les deux approches principales en `Python`,
        leurs points commun et les points par lesquels ils diff√®rent : 
        les environnements virtuels (g√©r√©s par un fichier `requirements.txt`)
        et les environnements conda (g√©r√©s par un fichier `environment.yml`)



## Limiter la redondance {#redondance}

Un bon principe √† suivre est _"don't repeat yourself !"_ (DRY).
Celui-ci r√©duit la charge de code √† √©crire, √† comprendre et √† 
tenir √† jour. 

{{< tweet 598532170160873472 >}}

Ce [post](https://www.earthdatascience.org/courses/intro-to-earth-data-science/write-efficient-python-code/intro-to-clean-code/dry-modular-code/) donne quelques bonnes pratiques
pour r√©duire la redondance des codes. 

::: {.callout-tip collapse="true"}

## Un exemple progressif pour comprendre

üí° Supposons qu'on dispose d'une table de donn√©es qui utilise le code `‚àí99` pour repr√©senter les valeurs manquantes.
On d√©sire remplacer l'ensemble des `‚àí99` par des `NA`.

Voici un code `Python` qui permet de se placer dans ce cas qui, malheureusement,
arrive fr√©quemment.

```python
# On fixe la racine pour √™tre s√ªr de tous avoir le m√™me dataset
np.random.seed(1234)

# On cr√©√© un dataframe
a = np.random.randint(1, 10, size = (5,6))
df = np.insert(
    a,
    np.random.choice(len(a), size=6),
    -99,
)
df = pd.DataFrame(df.reshape((6,6)), columns=[chr(x) for x in range(97, 103)])
```


Un premier jet de code pourrait prendre la forme suivante:

```python
# Dupliquer les donn√©es
df2 = df.copy()
# Remplacer les -99 par des NA
df2.loc[df2['a'] == -99,'a'] = np.nan
df2.loc[df2['b'] == -99,'b'] = np.nan
df2.loc[df2['c'] == -99,'c'] = np.nan
df2.loc[df2['d'] == -99,'d'] = np.nan
df2.loc[df2['e'] == -98,'e'] = np.nan
df2.loc[df2['f'] == -99,'e'] = np.nan
```

Quelles sont les choses qui vous d√©rangent dans le code ci-dessus?

<details>
<summary>
Indice üí° Regardez pr√©cis√©ment le code et le `DataFrame`, notamment les colonnes `e` et `g`.
</summary>
Il y a deux erreurs, difficiles √† d√©tecter:

- `df2.loc[df2['e'] == -98,'e'] = np.nan`: une erreur de copier-coller sur la valeur de l'erreur ;
- `df2.loc[df2['f'] == -99,'e'] = np.nan`: une erreur de copier-coller sur les colonnes en question
</details>

On peut noter au moins deux trois :

* Le code est long et r√©p√©titif, ce qui nuit √† sa lisibilit√©;
* Le code est tr√®s d√©pendant de la structure des donn√©es (nom et nombre de colonnes) et doit √™tre adapt√© d√®s que celle-ci √©volue;
* On a introduit des erreurs humaines dans le code, difficiles √† d√©tecter. 

On voit dans la premi√®re version de notre code qu'il y a une structure commune √† toutes nos lignes de la forme `.[. == -99] = np.nan`. Cette structure va servir de base √† notre fonction, en vue de g√©n√©raliser le traitement que nous voulons faire.

```python
def fix_missing(x: pd.Series):
    x[x == -99] = np.nan
    return x

df2 = df.copy()
df2['a'] = fix_missing(df['a'])
df2['b'] = fix_missing(df['b'])
df2['c'] = fix_missing(df['c'])
df2['d'] = fix_missing(df['d'])
df2['e'] = fix_missing(df['e'])
df2['f'] = fix_missing(df['f'])
```

Cette seconde version du code est meilleure que la premi√®re version, car on a r√©gl√© le probl√®me d'erreur humaine (il n'est plus possible de taper `-98` au lieu de `-99`).

<details>
<summary>
Mais voyez-vous le probl√®me qui persiste ?
</summary>

Le code reste long et r√©p√©titif, et n'√©limine pas encore toute possibilit√© d'erreur, car il est toujours possible de se tromper dans le nom des variables. 
</details>

La prochaine √©tape consiste √† √©liminer ce risque d'erreur en combinant deux fonctions (ce qu'on appelle la combinaison de fonctions).

La premi√®re fonction `fix_missing()` sert √† r√©gler le probl√®me sur un vecteur. La seconde g√©n√©ralisera ce proc√©d√© √† toutes les colonnes. Comme `Pandas` permet une approche vectorielle, il est fr√©quent de construire des fonctions sur des vecteurs et les appliquer ensuite √† plusieurs colonnes.


```python
def fix_missing(x: pd.Series):
    x[x == -99] = np.nan
    return x

df2 = df.copy()
df2 = df2.apply(fix_missing)
```

Cette troisi√®me version du code a plusieurs avantages sur les deux autres versions:

1. Elle est plus concise et plus lisible;
2. Si on a un changement de code pour les valeurs manquantes, il suffit de le mettre √† un seul endroit;
3. Elle fonctionne quels que soient le nombre de colonnes et le nom des colonnes;
4. On ne peut pas traiter une colonne diff√©remment des autres par erreur.

De plus, le code est facilement g√©n√©ralisable.

Par exemple, √† partir de la m√™me structure, √©crire le code qui permet de ne traiter que les colonnes *a*,*b* et *e*
ne demande pas beaucoup d'√©nergie.


```python
df2 = df.copy()
df2[['a','b','e']] = df2[['a','b','e']].apply(fix_missing)
```
:::

## (Auto)documentation {#documentation}

Un code sans aucun commentaire est tr√®s difficile √† s'approprier (y compris
pour la personne qui l'a r√©dig√© et qui y revient quelques semaines plus tard).
Cependant, un code pr√©sentant trop de commentaires est √©galement illisible et
refl√®te g√©n√©ralement un d√©faut de conception du code qui n'est pas assez
explicite. 

La documentation vise √† pr√©senter la d√©marche g√©n√©rale, √©ventuellement
√† travers des exemples, mais aussi √† expliciter certains √©l√©ments
du code (une op√©ration qui n'est pas √©vidente, des arguments de fonction, etc.). 
La documentation se m√©lange donc aux instructions visant √† √™tre ex√©cut√©es
mais s'en distingue. Ces principes sont h√©rit√©s du paradigme de la 
_"programmation lettr√©e"_ (_Literate programming_) dont l'un des 
avocats √©tait Donald Knuth. 


> _"Je crois que le temps est venu pour une am√©lioration significative de la documentation des programmes, et que le meilleur moyen d'y arriver est de consid√©rer les programmes comme des ≈ìuvres litt√©raires. D'o√π mon titre, ¬´ programmation lettr√©e¬´ ._
>
> _Nous devons changer notre attitude traditionnelle envers la construction des programmes : au lieu de consid√©rer que notre t√¢che principale est de dire √† un ordinateur ce qu'il doit faire, appliquons-nous plut√¥t √† expliquer √† des √™tres humains ce que nous voulons que l'ordinateur fasse._
>
> _Celui qui pratique la programmation lettr√©e peut √™tre vu comme un essayiste, qui s'attache principalement √† exposer son sujet dans un style visant √† l'excellence. Tel un auteur, il choisit , avec soin, le dictionnaire √† la main, les noms de ses variables et en explique la signification pour chacune d'elles. Il cherche donc √† obtenir un programme compr√©hensible parce que ses concepts sont pr√©sent√©s dans le meilleur ordre possible. Pour cela, il utilise un m√©lange de m√©thodes formelles et informelles qui se compl√®tent"_
>
> Donald Knuth, _Literate Programming_ ([source](https://fr.wikipedia.org/wiki/Programmation_lettr%C3%A9e))

Cela peut amener √† distinguer deux types de documentation:

1. Une documentation g√©n√©rale de type `Jupyter Notebook` ou `Quarto Markdown` qui 
pr√©sente certes du code ex√©cut√© mais dont l'objet principal est de pr√©senter
une d√©marche ou des r√©sultats ;
2. Une documentation de la d√©marche plus proche du code dont l'un des 
exemples sont les _docstrings_ `Python` (ou son √©quivalent `R`, la documentation `Roxygen`).


Les deux grands principes de la documentation au sein d'un script sont les suivants:

- Il est pr√©f√©rable de __documenter le pourquoi plut√¥t que le comment__. Le _"comment"_ devrait
√™tre compr√©hensible √† la lecture du code ;
- Privil√©gier l'autodocumentation via des __nommages pertinents__


::: {.callout-tip}
## Comment bien documenter un script ?

- **Minimum** üö¶ : commentaire au d√©but du script pour d√©crire ce qu'il fait
- **Bien** üëç : commenter les parties "d√©licates" du code
- **Id√©al** üí™ : documenter ses fonctions avec la syntaxe des `docstrings`.

:::


## Outils et m√©thodes pour am√©liorer un code

L'apprentissage par coeur de ces r√®gles ou
faire des aller-retour en continu entre le code
et les manuels de r√®gles 
serait quelques
peu r√©barbatif.

Pour faire le parall√®le avec
le langage naturel, on n'a pas toujours le b√©cherelle 
ou le dictionnaire sous les yeux. Les √©diteurs de 
texte ou les smartphones embarquent des correcteurs
orthographiques qui identifient voire corrigent
directement le texte √©crit. 

Il existe le m√™me type d'outils pour les langages
de programmation.
`Python` √©tant l'outil de travail principal de milliers de 
_data-scientists_, un certain nombre d'outils ont vu le jour
pour r√©duire le temps n√©cessaire pour cr√©er un projet ou disposer
d'un code fonctionnel. Ces outils permettent un gros gain de productivit√©,
r√©duisent le temps pass√© √† effectuer des t√¢ches r√©barbatives et am√©liorent
la qualit√© d'un projet en offrant des diagnostics voire des correctifs
√† des codes perfectibles. 


Les principaux outils sont les suivants:

1. **_linter_** : programme qui v√©rifie que le code est __formellement__ conforme √† un certain _guidestyle_
    + signale probl√®mes formels, sans corriger 
2. **_formatter_** : programme qui reformate un code pour le rendre conforme √† un certain _guidestyle_
    + modifie directement le code


::: {.callout-tip}
- Exemples d‚Äôerreurs rep√©r√©es par un _linter_ : 
    + lignes de code trop longues ou mal indent√©es, parenth√®ses non √©quilibr√©es, noms de fonctions mal construits‚Ä¶
- Exemples d‚Äôerreurs __non__ rep√©r√©es par un _linter_ :
    + fonctions mal utilis√©es, arguments mal sp√©cifi√©s, structure du code incoh√©rente, code insuffisamment document√©‚Ä¶
:::


## _Linters_

Les _linters_ sont des outils qui permettent d'√©valuer la qualit√© du 
code et son risque de provoquer une erreur (explicite ou silencieuse).

Voici quelques exemples de probl√®mes que peuvent rencontrer les 
`linters`:

* les variables sont utilis√©es mais n'existent pas (erreur)
* les variables inutilis√©es (inutiles)
* la mauvaise organisation du code (risque d'erreur)
* le non respect des bonnes pratiques d'√©criture de code
* les erreurs de syntaxe (par exemple les coquilles)
    
La plupart des logiciels de d√©veloppement embarquent des fonctionalit√©s
de diagnostic (voire de suggestion de correctif). Il faut parfois
les param√©trer dans les options (ils sont d√©sactiv√©s pour ne pas
effrayer l'utilisateur avec des croix rouges partout).

En `Python`, les deux principaux _linters_
sont [`PyLint`](https://pylint.readthedocs.io/en/latest/) et
[`Flake8`](https://flake8.pycqa.org/en/latest/). 
Dans les exercices, nous proposons d'utiliser `PyLint` qui est
pratique. 

::: {.callout-tip}

L'un des int√©r√™ts d'utiliser `PyLint` est qu'on obtient une note,
ce qui est assez instructif. Nous l'utiliserons dans l'application
fil rouge pour comprendre la mani√®re dont chaque √©tape am√©liore
la qualit√© du code. 

Il est possible de mettre en oeuvre des [_pre commit hook_](https://pylint.readthedocs.io/en/latest/user_guide/installation/pre-commit-integration.html) qui emp√™chent un
_commit_ n'ayant pas une note minimale. 

:::



## _Formaters_

Le _formater_ modifie directement le code. On peut
faire un parall√®le avec le correcteur orthographique.

Cet outil peut
donc induire un changement substantiel du script
afin de le rendre plus lisible.  

Le _formater_ le plus utilis√©
est [`Black`](https://black.readthedocs.io/en/stable/). 


::: {.callout-note}

Pour signaler sur `Github`
la qualit√© d'un projet utilisant `Black`, il est possible
d'ajouter un badge dans le `README`:

[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

:::

# M√©thodes compl√©mentaires pour favoriser la qualit√© d'un script

## Relecture par un tiers / pair-programming



# R√©f√©rences

- [The Hitchhiker‚Äôs Guide to Python](https://docs.python-guide.org/#writing-great-python-code)
- [_Tidyverse Style Guide_](https://style.tidyverse.org/googl)
- [_Google Style Guide_](https://google.github.io/styleguide/Rguide.html)
- [Cours de Pierre-Antoine Champin](https://perso.liris.cnrs.fr/pierre-antoine.champin/enseignement/algo/cours/algo/bonnes_pratiques.html)
- [_R Packages_](https://r-pkgs.org/index.html) par Hadley Wickham and Jenny Bryan
- [La documentation collaborative `utilitR`](https://www.book.utilitr.org)
- [_Project Oriented Workflow_](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)
- [Un post tr√®s complet sur les extensions VisualStudio](https://realpython.com/advanced-visual-studio-code-python/)
- [_"Coding style, coding etiquette"_](https://blog.r-hub.io/2022/03/21/code-style/)
- [Une pr√©sentation tr√®s bien faite sur la gestion de code et de projets  `R`](https://mitmat.github.io/slides/2022-05-26-egu/code-data-open-science.html#1)
