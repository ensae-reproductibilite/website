:::: {.content-visible when-profile="fr"}

# Les conteneurs üêã

![Image trouv√©e sur [reddit](https://www.reddit.com/r/ProgrammerHumor/comments/cw58z7/it_works_on_my_machine/)
](https://external-preview.redd.it/aR6WdUcsrEgld5xUlglgKX_0sC_NlryCPTXIHk5qdu8.jpg?auto=webp&s=5fe64dd318eec71711d87805d43def2765dd83cd){fig-align="center"}

## Introduction

Avec les environnements virtuels,  
l'id√©e √©tait de permettre √† chaque utilisateur potentiel de notre projet d'installer sur son environnement d'ex√©cution les packages n√©cessaires √† la bonne ex√©cution du projet.

N√©anmoins, comme on l'a vu, cette approche ne garantit pas une reproductibilit√© parfaite et a l'inconv√©nient de demander beaucoup de gestion manuelle.

Changeons de perspective : _au lieu de distribuer une recette permettant √† l'utilisateur de recr√©er l'environnement n√©cessaire sur sa machine, ne pourrait-on pas directement distribuer √† l'utilisateur une machine contenant l'environnement pr√©-configur√© ?_

Bien entendu, on ve pas configurer et envoyer des ordinateurs portables √† tous les utilisateurs potentiels d'un projet.  
On va donc essayer de livrer une version virtuelle  
de notre ordinateur. Il existe deux approches principales pour cela:

- Les __machines virtuelles__. Cette approche n'est pas nouvelle.  Elle consiste √† recr√©er, sur un serveur, un environnement informatique complet (mat√©riel et syst√®me d'exploitation) qui r√©plique le comportement d'un v√©ritable ordinateur.
- Les __conteneurs__, une solution plus l√©g√®re pour empaqueter un environnement informatique afin de r√©pliquer le comportement d'une machine r√©elle.

## Fonctionnement

Les machines virtuelles ont l'inconv√©nient d'√™tre assez lourdes, et complexes √† r√©pliquer et distribuer. Pour pallier ces diff√©rentes limites, les conteneurs se sont impos√©s au cours de la derni√®re d√©cennie. Toutes les infrastructures _cloud_ modernes ont progressivement abandonn√© les machines virtuelles pour privil√©gier des conteneurs pour les raisons que nous allons √©voquer ult√©rieurement.

Comme les machines virtuelles, les conteneurs permettent d'empaqueter compl√®tement l'environnement (librairies syst√®mes, application, configuration) qui permet de faire tourner l'application.  
Mais √† l'inverse d'une machine virtuelle, le conteneur n'inclut pas de syst√®me d'exploitation propre, il utilise celui de la machine h√¥te qui l'ex√©cute.  
Cela signifie que si on d√©sire reproduire le comportement d'une machine Windows, il n'est pas n√©cessaire d'avoir un gros serveur avec Windows. Il est tout √† fait possible d'avoir un serveur Linux, ce qui est la norme, et de r√©pliquer le comportement d'une machine Windows √† l'int√©rieur. A l'inverse, cela peut permettre de tester des configurations Linux ou Mac sur un ordinateur Windows. C'est le r√¥le du logiciel de conteneurisation qui fera la traduction entre les instructions voulues par le _software_ et le syst√®me d'exploitation du _hardware_.

La technologie des conteneurs permet ainsi de garantir une tr√®s forte reproductibilit√© tout en restant suffisamment l√©g√®re pour permettre une distribution et un d√©ploiement simple aux utilisateurs. En effet, l'adh√©rence forte entre un syst√®me d'exploitation et un logiciel dans l'approche des machines virtuelles rend plus complexe la mont√©e en charge d'un serveur. Si plus d'utilisateurs commencent √† utiliser l'application, il est n√©cessaire de s'assurer que des serveurs correspondant aux besoins de l'application (syst√®me d'exploitation, configurations techniques, etc.) soient disponibles. Avec les conteneurs, la mont√©e en charge est plus simple puisque les restrictions mat√©rielles sont moins fortes: ajouter un serveur Linux avec les logiciels ad√©quats peut √™tre suffisant.

![Diff√©rences entre l'approche conteneurs (gauche) et l'approche machines virtuelles (droite) (Source : [docker.com](https://www.docker.com/resources/what-container/))](/docker-vm.png)

Du point de vue de l'utilisateur, la diff√©rence n'est pas toujours perceptible pour des besoins standards.  
L'utilisateur acc√©dera √† son application par une application d√©di√©e (un navigateur, un logiciel sp√©cialis√©...) et les calculs issus des op√©rations effectu√©es seront d√©port√©s sur les serveurs o√π est h√©berg√©e cette application. N√©anmoins, pour l'organisation qui g√®re cette application, les conteneurs offriront plus de libert√© et de flexibilit√© comme nous l'avons √©voqu√©.

## `Docker` {{< fa brands docker >}}, l'impl√©mentation standard

Comme nous l'avons √©voqu√©, le logiciel de conteneurisation fait office de couche tampon entre les applications et le syst√®me d'exploitation du serveur.

Comme pour les environnements virtuels, il existe diff√©rentes impl√©mentations de la technologie des conteneurs. En pratique, l'impl√©mentation offerte par `Docker` est devenue largement pr√©dominante, au point qu'il est devenu courant d'utiliser de mani√®re interchangeable les termes _"conteneuriser"_ et _"Dockeriser"_ une application. C'est donc cette impl√©mentation que nous allons √©tudier et utiliser dans ce cours.

### Installation et environnements bacs √† sable

`Docker` {{< fa brands docker >}} est un logiciel qui peut s'installer sur diff√©rents syst√®me d'exploitation.  
Les instructions sont d√©taill√©es dans la [documentation officielle](https://docs.docker.com/get-docker/).  
Il est n√©cessaire d'avoir des droits administrateurs sur son poste pour pouvoir faire cette installation.

::: {.callout-warning collapse="true"}
## Besoins en espace disque

Il est √©galement recommand√© d'avoir de l'espace disque libre car certaines images (concept sur lequel nous reviendrons), une fois d√©compress√©es et construites, peuvent √™tre lourdes selon la richesse des librairies install√©es dessus. Elles peuvent rapidement prendre quelques Gigas d'espace disque.

Ceci est n√©anmoins √† comparer √† l'espace disque monstrueux que peut prendre un syst√®me d'exploitation complet (autour de 15GB pour Ubuntu ou Mac OS, 20GB par exemple pour Windows...). La distribution Linux la plus minimaliste ([Alpine](https://hub.docker.com/_/alpine/tags)) ne fait que 3Mo compress√©e et 5Mo une fois d√©compress√©e.
:::

Il existe √©galement des environnements en ligne gratuits pouvant servir de bacs √† sable s'il n'est pas possible pour vous d'installer `Docker`.  
_[Play with Docker](https://labs.play-with-docker.com)_ permet de tester en ligne `Docker` comme on pourrait le faire sur une installation personnelle. N√©anmoins, ces services sont limit√©s: la taille maximale des images d√©compress√©es est limit√©e √† 2Go, les services connaissent des coupures en cas d'utilisation massive...

Comme nous le verrons ult√©rieurement, l'utilisation de `Docker` en interactif est pratique pour apprendre et exp√©rimenter. N√©anmoins, en pratique, on utilise principalement `Docker` par le biais de l'int√©gration continue via `Github Actions` ou `Gitlab CI`.

### Principes

![Source : [k21academy.com](https://k21academy.com/docker-kubernetes/docker-and-kubernetes/)](https://ensae-reproductibilite.github.io/slides/img/docker-workflow.png)

Un conteneur Docker est mis √† disposition sous la forme d'une **image**, c'est √† dire d'un fichier binaire qui contient l'environnement n√©cessaire √† l'ex√©cution de l'application. Celui-ci est mis √† disposition de tous sous une forme compress√©e sur un d√©p√¥t d'images publiques (le plus connu est `Dockerhub`).

Avant de mettre √† disposition une image, il est n√©cessaire de la construire (*build*).  
Pour cela on utilise un `Dockerfile`, un fichier texte qui contient la recette ‚Äî sous forme de commandes Linux ‚Äî de construction de l'environnement.

Une fois l'image construite, il est possible de faire deux actions:

- La lancer (*run*) en local. Cela permet de tester l'application, √©ventuellement de la corriger en cas de mauvais fonctionnement. Le lancement de l'application permet de faire tourner l'image dans un environnement isol√© qu'on appelle le conteneur (*container*), une instance vivante de l'image en quelques sortes[^assimilation].
- La mettre √† disposition sur un d√©p√¥t public pour permettre √† d'autres (ou √† soi-m√™me) de la tester.  
L'image va √™tre upload√©e (*push*) sur un d√©p√¥t (*registry*), public ou priv√©, depuis lequel les utilisateurs vont pouvoir t√©l√©charger l'image (*pull*).

[^assimilation]: Par abus de langage, on m√©lange souvent les termes _"image"_ et _"conteneur"_. En pratique ces deux concepts sont tr√®s proches.  
Le second correspond √† la version vivante du premier.

::: {.callout-note collapse="true"}
## Mettre √† disposition son image `Docker`

Le r√©pertoire d'images publiques le plus connu est [`DockerHub`](https://hub.docker.com/). Il s'agit d'un r√©pertoire o√π n'importe qui peut proposer une image `Docker`, associ√©e ou non √† un projet disponible sur `Github` ou `Gitlab`. Il est possible de mettre √† disposition de mani√®re manuelle des images mais, comme nous le montrerons dans le chapitre sur la [mise en production](/chapters/deployment.html), il est beaucoup plus pratique d'utiliser des fonctionalit√©s d'interaction automatique entre `DockerHub` et un d√©p√¥t `GitHub`.
:::

::::
:::: {.content-visible when-profile="en"}

# Containers üêã

![Image found on [reddit](https://www.reddit.com/r/ProgrammerHumor/comments/cw58z7/it_works_on_my_machine/)
](https://external-preview.redd.it/aR6WdUcsrEgld5xUlglgKX_0sC_NlryCPTXIHk5qdu8.jpg?auto=webp&s=5fe64dd318eec71711d87805d43def2765dd83cd){fig-align="center"}

## Introduction

With virtual environments,  
the goal was to allow every potential user of our project to install the required packages on their system for proper execution.

However, as we‚Äôve seen, this approach doesn‚Äôt ensure perfect reproducibility and requires significant manual effort.

Let‚Äôs shift perspective: _instead of giving users a recipe to recreate the environment on their machine, couldn‚Äôt we just give them a pre-configured machine?_

Of course, we‚Äôre not going to configure and ship laptops to every potential user.  
So we aim to deliver a virtual version  
of our machine. There are two main approaches:

- __Virtual machines__: not a new approach. They simulate a full computing environment (hardware + OS) on a server to replicate a real computer‚Äôs behavior.
- __Containers__: a more lightweight solution to bundle a computing environment and mimic a real machine's behavior.

## How it works

Virtual machines are heavy and difficult to replicate or distribute.  
To overcome these limitations, containers have emerged in the past decade.  
Modern cloud infrastructure has largely moved from virtual machines to containers for the reasons we‚Äôll discuss.

Like VMs, containers package the full environment (system libraries, app, configs) needed to run an app.  
But unlike VMs, containers don‚Äôt include their own OS. Instead, they use the host machine‚Äôs OS.  
This means to simulate a Windows machine, you don‚Äôt need a Windows server ‚Äî a Linux one will do. Conversely, you can test Linux/Mac setups on a Windows machine.  
The containerization software handles the translation between software-level instructions and the host OS.

This technology guarantees strong reproducibility while remaining lightweight enough for easy distribution and deployment.  
With VMs, strong coupling between the OS and the app makes scaling harder. You need to spin up new servers matching your app‚Äôs needs (OS, configs).  
With containers, scaling is easier: just add Linux servers with the right tools and you're good to go.

![Differences between containers (left) and VMs (right) (Source: [docker.com](https://www.docker.com/resources/what-container/))](/docker-vm.png)

From the user‚Äôs point of view, the difference is often invisible for typical usage.  
They access the app via a browser or tool, and computations happen on the remote server.  
But for the organization hosting the app, containers bring more freedom and flexibility.

## `Docker` {{< fa brands docker >}}, the standard implementation

As mentioned, the containerization software acts as a bridge between applications and the server‚Äôs OS.

As with virtual environments, there are multiple container technologies.  
In practice, `Docker` has become the dominant one ‚Äî to the point where ‚Äúcontainerize‚Äù and ‚ÄúDockerize‚Äù are often used interchangeably.  
We will focus on Docker in this course.

### Installation & sandbox environments

`Docker` {{< fa brands docker >}} can be installed on various operating systems.  
Installation instructions are in the [official documentation](https://docs.docker.com/get-docker/).  
You need admin rights on your computer to install it.

::: {.callout-warning collapse="true"}
## Disk space requirements

It‚Äôs also recommended to have free disk space, as some images (we‚Äôll come back to that) can be large once decompressed and built.  
They may take up several GBs depending on the libraries included.

Still, this is small compared to a full OS (15GB for Ubuntu or macOS, 20GB for Windows...).  
The smallest Linux distribution ([Alpine](https://hub.docker.com/_/alpine/tags)) is only 3MB compressed and 5MB uncompressed.
:::

If you can't install Docker, there are free online sandboxes.  
_[Play with Docker](https://labs.play-with-docker.com)_ lets you test Docker as if it were on your local machine.  
These services are limited though (2GB max image size, outages under heavy load...).

As we‚Äôll see, interactive Docker usage is great for learning.  
But in practice, Docker is mostly used via CI systems like `GitHub Actions` or `Gitlab CI`.

### Concepts

![Source: [k21academy.com](https://k21academy.com/docker-kubernetes/docker-and-kubernetes/)](https://ensae-reproductibilite.github.io/slides/img/docker-workflow.png)

A Docker container is delivered as an **image**: a binary file containing the environment needed to run an app.  
It‚Äôs shared in compressed form on a public image repository (e.g., `Dockerhub`).

Before sharing, you must *build* the image.  
That‚Äôs done using a `Dockerfile`, a text file with Linux commands describing how to set up the environment.

Once built, you can:

- *Run* it locally to test and debug the app.  
  Running it creates an isolated environment called a *container* ‚Äî a live instance of the image[^assimilation].
- *Push* it to a public or private repository so others (or yourself) can *pull* and use it.

[^assimilation]: The terms ‚Äúimage‚Äù and ‚Äúcontainer‚Äù are often used interchangeably.  
Technically, a container is the live version of an image.

::: {.callout-note collapse="true"}
## Publishing your Docker image

The most well-known image repository is [`DockerHub`](https://hub.docker.com/).  
Anyone can publish a Docker image there, optionally linked to a GitHub or Gitlab project.  
While you can upload images manually, as we‚Äôll see in the [deployment chapter](/chapters/deployment.html), it's much better to use automated links between `DockerHub` and your `GitHub` repo.
:::

::::
