::: {.content-visible when-profile="fr"}

## Construction d'une image Docker {#build}

Pour construire une image Ã  partir d'un `Dockerfile`, il suffit d'utiliser la commande `docker build` depuis la ligne de commande[^windows]. Il faut ensuite spÃ©cifier deux Ã©lÃ©ments importants :

- le __*build context*__. Il faut indiquer Ã  `Docker` le chemin de notre projet, qui doit contenir le `Dockerfile`. En pratique, il est plus simple de se mettre dans le dossier du projet via la commande `cd`, puis de passer `.` comme *build context* pour indiquer Ã  `Docker` de *build* "d'ici" ;
- le __*tag*__, c'est Ã  dire le nom de l'image. Tant que l'on utilise `Docker` en local, le *tag* importe peu. On verra par la suite que la structure du *tag* a de l'importance lorsque l'on souhaite [exporter](#imp-docker) ou [importer](#exp-docker) une image `Docker` Ã  partir d'un dÃ©pÃ´t distant.

[^windows]: Si vous Ãªtes sur Windows, les lignes de commande disponibles par dÃ©faut (`cmd` ou `Powershell`) sont peu pratiques. Il est recommandÃ© d'utiliser la ligne de commande de `Git Bash` (une Ã©mulation minimaliste d'une ligne de commande `Linux`) qui vous permettra de faire des opÃ©rations en ligne de commande.

Regardons ce qui se passe en pratique lorsque l'on essaie de construire notre image. Le tag de celle-ci est `myflaskapp`:

```{.bash filename="terminal"}
docker build -t myflaskapp .
```

```{.python}
Sending build context to Docker daemon     47MB
Step 1/8 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/8 : RUN apt-get update && apt-get install -y python3-pip python3-dev
 ---> Running in 92b42d579cfa
...
done.
Removing intermediate container 92b42d579cfa
 ---> 8826d53e3c01
Step 3/8 : WORKDIR /app
 ---> Running in 153b32893c23
Removing intermediate container 153b32893c23
 ---> 7b4d22021986
Step 4/8 : COPY requirements.txt /app/requirements.txt
...
Successfully built 125bd8da70ff
Successfully tagged myflaskapp:latest
```



Le moteur `Docker` essaie de construire notre image sÃ©quentiellement Ã  partir des commandes spÃ©cifiÃ©es dans le `Dockerfile`. S'il rencontre une erreur, la procÃ©dure s'arrÃªte, et il faut alors trouver la source du problÃ¨me dans les *logs* et adapter le `Dockerfile` en consÃ©quence.

Si tout se passe bien, `Docker` nous indique que le *build* a rÃ©ussi et l'image est prÃªte Ã  Ãªtre utilisÃ©e. On peut vÃ©rifier que l'image est bien disponible Ã  l'aide de la commande `docker images`.

```{.bash filename="terminal"}
docker images
```

```{.python}
REPOSITORY                               TAG       IMAGE ID       CREATED          SIZE
myflaskapp                               latest    57d2f410a631   2 hours ago      433MB
```

IntÃ©ressons nous un peu plus en dÃ©tail aux *logs* de l'Ã©tape de *build* ðŸ‘†ï¸.

Entre les Ã©tapes, `Docker` affiche des suites de lettres et de chiffres un peu Ã©sotÃ©riques, et nous parle de conteneurs intermÃ©diaires. En fait, il faut voir une image `Docker` comme un empilement de couches (*layers*), qui sont elles-mÃªmes des images `Docker`. Quand on hÃ©rite d'une image avec l'instruction `FROM`, on spÃ©cifie donc Ã  `Docker` la couche initiale, sur laquelle il va construire le reste de notre environnement. A chaque Ã©tape sa nouvelle couche, et Ã  chaque couche son *hash*, un identifiant unique fait de lettres et de chiffres.

Cela peut ressembler Ã  des dÃ©tails techniques, mais c'est en fait extrÃªmement utile en pratique car cela permet Ã  `Docker` de faire du *caching*. Lorsqu'on dÃ©veloppe un `Dockerfile`, il est frÃ©quent de devoir modifier ce dernier de nombreuses fois avant de trouver la bonne recette, et on aimerait bien ne pas avoir Ã  *rebuild* l'environnement complet Ã  chaque fois. `Docker` gÃ¨re cela trÃ¨s bien : il *cache* chacune des couches intermÃ©diaires[^cacheCI].

Par exemple, si l'on modifie la 5Ã¨me commande du `Dockerfile`, `Docker` va utiliser le cache pour ne pas avoir Ã  recalculer les Ã©tapes prÃ©cÃ©dentes, qui n'ont pas changÃ©. Cela s'appelle l'_"invalidation du cache"_ :
dÃ¨s lors qu'une Ã©tape du `Dockerfile` est modifiÃ©e, `Docker` va recalculer toutes les Ã©tapes suivantes, mais seulement celles-ci. ConsÃ©quence directe de cette observation : il faut toujours ordonner les Ã©tapes d'un `Dockerfile` de sorte Ã  ce qui est le plus susceptible d'Ãªtre souvent modifiÃ© soit Ã  la fin du fichier, et inversement.

[^cacheCI]: Le _cache_ est trÃ¨s pratique pour une construction expÃ©rimentale en local. Malheureusement, lorsqu'on passe par des services d'intÃ©gration continue, l'utilisation du _cache_ est moins Ã©vidente car chaque `run` se fait sur une machine indÃ©pendante de la prÃ©cÃ©dente.

Pour illustrer cela, regardons ce qui se passe si l'on modifie le nom du script qui lance l'application, et donc la valeur de la variable d'environnement `FLASK_APP` dans le `Dockerfile`.

```{.bash filename="terminal"}
docker build . -t myflaskapp
```

```{.python}
Sending build context to Docker daemon  4.096kB
Step 1/10 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/10 : ENV DEBIAN_FRONTEND=noninteractive
 ---> Using cache
 ---> ea1c7c083ac9
Step 3/10 : RUN apt-get update -y &&     apt-get install -y python3-pip python3-dev
 ---> Using cache
 ---> 078b8ac0e1cb
Step 4/10 : WORKDIR /app
 ---> Using cache
 ---> cd19632825b3
Step 5/10 : COPY requirements.txt /app/requirements.txt
 ---> Using cache
 ---> 271cd1686899
Step 6/10 : RUN pip install -r requirements.txt
 ---> Using cache
 ---> 3ea406fdf383
Step 7/10 : COPY . /app
 ---> 3ce5bd3a9572
Step 8/10 : ENV FLASK_APP="new.py"
 ---> Running in b378d16bb605
Removing intermediate container b378d16bb605
 ---> e1f50490287b
Step 9/10 : EXPOSE 5000
 ---> Running in ab53c461d3de
Removing intermediate container ab53c461d3de
 ---> 0b86eca40a80
Step 10/10 : CMD ["flask", "run", "--host=0.0.0.0"]
 ---> Running in 340eec151a51
Removing intermediate container 340eec151a51
 ---> 16d7a5b8db28
Successfully built 16d7a5b8db28
Successfully tagged myflaskapp:latest
```

L'Ã©tape de *build* a pris quelques secondes au lieu de plusieurs minutes, et les *logs* montrent bien l'utilisation du cache faite par `Docker` : les Ã©tapes prÃ©cÃ©dant le changement rÃ©utilisent les couches cachÃ©es, mais celle d'aprÃ¨s sont recalculÃ©es.

## ExÃ©cuter (_run_) une image `Docker` {#execution}

L'Ã©tape de *build* a permis de crÃ©er une *image* `Docker`. Une image doit Ãªtre vue comme un *template* : elle permet d'exÃ©cuter l'application sur n'importe quel environnement d'exÃ©cution sur lequel un moteur `Docker` est installÃ©.

En l'Ã©tat, on a donc juste *construit*, mais rien *lancÃ©* : notre application ne tourne pas encore. Pour cela, il faut crÃ©er un *conteneur*, i.e. une instance vivante de l'image qui permet d'accÃ©der Ã  l'application. Cela se fait via la commande `docker run`.

```{.bash filename="terminal" no-prefix=true}
$ docker run -d -p 8000:5000 myflaskapp:latest
6a2ab0d82d051a3829b182ede7b9152f7b692117d63fa013e7dfe6232f1b9e81
```

DÃ©taillons la syntaxe de cette commande :

- `docker run tag` : lance l'image dont on fournit le *tag*. Le *tag* est de la forme `repository/projet:version`. Ici, il n'y a pas de *repository* puisque tout est fait en local ;
- `-d` : "dÃ©tache" le conteneur du terminal qui le lance ;
- `-p` : effectue un *mapping* entre un port de la machine qui exÃ©cute le conteneur, et le conteneur lui-mÃªme. Notre conteneur Ã©coute sur le port 5000, et l'on veut que notre application soit exposÃ©e sur le port 8000 de notre machine.

Lorsque l'on exÃ©cute `docker run`, `Docker` nous rÃ©pond simplement un *hash* qui identifie le conteneur que l'on a lancÃ©. On peut vÃ©rifier qu'il tourne bien avec la commande `docker ps`, qui renvoie toutes les informations associÃ©es au conteneur.

```{.bash filename="terminal"}
docker ps
```

```{.python}
CONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS         PORTS                                   NAMES
6a2ab0d82d05   myflaskapp   "flask run --host=0.â€¦"   7 seconds ago   Up 6 seconds   0.0.0.0:8000->5000/tcp, :::8000->5000/tcp   vigorous_kalam
```

Les conteneurs peuvent Ãªtre utilisÃ©s pour rÃ©aliser des tÃ¢ches trÃ¨s diffÃ©rentes. GrossiÃ¨rement, on peut distinguer deux situations :

- le conteneur effectue une tÃ¢che "one-shot", c'est Ã  dire une opÃ©ration qui a vocation Ã  s'effectuer en un certain temps, suite Ã  quoi le conteneur peut s'arrÃªter ;
- le conteneur exÃ©cute une application. Dans ce cas, on souhaite que le conteneur reste en vie aussi longtemps que l'on souhaite utiliser l'application en question.

Dans notre cas d'application, on se situe dans la seconde configuration puisque l'on veut exÃ©cuter une application web. Lorsque l'application tourne, elle expose sur le *localhost*, accessible depuis un navigateur web â€” en l'occurence, Ã  l'adresse [localhost:5000/](localhost:5000/). Les calculs sont effectuÃ©s sur un serveur local, et le navigateur sert d'interface avec l'utilisateur â€” comme lorsque vous utilisez un _notebook_ `Jupyter` par exemple.

Finalement, on a pu dÃ©velopper et exÃ©cuter une application complÃ¨te sur notre environnement local, sans avoir eu Ã  installer quoi que ce soit sur notre machine personnelle, Ã  part `Docker.`


::::

:::: {.content-visible when-profile="en"}

## Building a Docker Image {#build}

To build an image from a `Dockerfile`, use the `docker build` command from the terminal[^windows]. Two important arguments must be provided:

- the **build context**: this tells Docker where the project is located (it should contain the `Dockerfile`). The simplest approach is to navigate into the project directory via `cd` and pass `.` to indicate "build from here";
- the **tag**, i.e., the name of the image. While working locally, the tag doesnâ€™t matter much, but weâ€™ll see later that it becomes important when [exporting](#imp-docker) or [importing](#exp-docker) an image from/to a remote repository.

[^windows]: On Windows, the default command lines (`cmd` or `PowerShell`) are not very convenient. We recommend using the `Git Bash` terminal, a lightweight Linux command-line emulator, for better compatibility with command-line operations.

Letâ€™s see what happens when we try to build our image with the tag `myflaskapp`:

```{.bash filename="terminal"}
docker build -t myflaskapp .
```

```{.python}
Sending build context to Docker daemon     47MB
Step 1/8 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/8 : RUN apt-get update && apt-get install -y python3-pip python3-dev
 ---> Running in 92b42d579cfa
...
done.
Removing intermediate container 92b42d579cfa
 ---> 8826d53e3c01
...
Successfully built 125bd8da70ff
Successfully tagged myflaskapp:latest
```

Dockerâ€™s engine processes the instructions from the `Dockerfile` one at a time. If thereâ€™s an error, the build stops, and youâ€™ll need to debug the problem using the log output and adjust the `Dockerfile` accordingly.

If successful, Docker will indicate that the build was completed and that the image is ready for use. You can confirm its presence with the `docker images` command:

```{.bash filename="terminal"}
docker images
```

```{.python}
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
myflaskapp   latest    57d2f410a631   2 hours ago      433MB
```

Letâ€™s look more closely at the build logs ðŸ‘†ï¸.

Between each step, Docker prints cryptic hashes and mentions intermediate containers. Think of a Docker image as a stack of **layers**, each layer being itself a Docker image. The `FROM` instruction specifies the starting layer. Each command adds a new layer with a unique hash.

This design is not just technical triviaâ€”itâ€™s incredibly useful in practice because Docker **caches** each intermediate layer[^cacheCI].

For example, if you modify the 5th instruction in the `Dockerfile`, Docker will reuse the cache for previous layers and only rebuild from the change onward. This is called **cache invalidation**: once a step changes, Docker recalculates that step and all that follow, but no more. As a result, you should always place frequently changing steps at the end of the file.

[^cacheCI]: Caching is very useful for local development. Unfortunately, itâ€™s harder to leverage in CI environments, since each run usually happens on a fresh machine.

Letâ€™s illustrate this by changing the `FLASK_APP` environment variable in the `Dockerfile`:

```{.bash filename="terminal"}
docker build . -t myflaskapp
```

```{.python}
Sending build context to Docker daemon  4.096kB
Step 1/10 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/10 : ENV DEBIAN_FRONTEND=noninteractive
 ---> Using cache
 ---> ea1c7c083ac9
Step 3/10 : RUN apt-get update -y && ...
 ---> Using cache
 ---> 078b8ac0e1cb
...
Step 8/10 : ENV FLASK_APP="new.py"
 ---> Running in b378d16bb605
...
Successfully built 16d7a5b8db28
Successfully tagged myflaskapp:latest
```

The build finishes in seconds instead of minutes. The logs show that previous steps were cached, and only modified or dependent ones were rebuilt.

## Running a Docker Image {#execution}

The `build` step created a **Docker image**â€”essentially a blueprint for your app. It can be executed on any environment with Docker installed.

So far, weâ€™ve built the image but havenâ€™t **run** it. To launch the app, we must create a **container**, i.e., a live instance of the image. This is done with the `docker run` command:

```{.bash filename="terminal" no-prefix=true}
$ docker run -d -p 8000:5000 myflaskapp:latest
6a2ab0d82d051a3829b182ede7b9152f7b692117d63fa013e7dfe6232f1b9e81
```

Hereâ€™s a breakdown of the command:

- `docker run tag`: runs the image specified by `tag`. Tags usually follow the format `repository/project:version`. Since we're local, there's no repository;
- `-d`: runs the container in **detached** mode (in the background);
- `-p`: maps a port on the host machine (8000) to a port inside the container (5000). Since Flask listens on port 5000, this makes the app accessible via `localhost:8000`.

The command returns a long hashâ€”this is the container ID. You can verify that itâ€™s running with:

```{.bash filename="terminal"}
docker ps
```

```{.python}
CONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS         PORTS                                   NAMES
6a2ab0d82d05   myflaskapp   "flask run --host=0.â€¦"   7 seconds ago   Up 6 seconds   0.0.0.0:8000->5000/tcp, :::8000->5000/tcp   vigorous_kalam
```

Docker containers serve different purposes. Broadly, they fall into two categories:

- **One-shot jobs**: containers that execute a task and terminate;
- **Running apps**: containers that persist while serving an application.

In our case, weâ€™re in the second category. We want to run a web app, so the container must stay alive. Flask launches a server on a local port (5000), and weâ€™ve mapped it to port 8000 on our machine. You can access the app from your browser at [localhost:8000](http://localhost:8000/), just like a Jupyter notebook.

In the end, weâ€™ve built and launched a fully working application on our local machineâ€”without installing anything beyond Docker itself.

::::