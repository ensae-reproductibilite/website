::: {.content-visible when-profile="fr"}

## Construction d'une image Docker {#build}

Pour construire une image √† partir d'un `Dockerfile`, il suffit d'utiliser la commande `docker build` depuis la ligne de commande[^windows]. Il faut ensuite sp√©cifier deux √©l√©ments importants :

- le __*build context*__. Il faut indiquer √† `Docker` le chemin de notre projet, qui doit contenir le `Dockerfile`. En pratique, il est plus simple de se mettre dans le dossier du projet via la commande `cd`, puis de passer `.` comme *build context* pour indiquer √† `Docker` de *build* "d'ici" ;
- le __*tag*__, c'est √† dire le nom de l'image. Tant que l'on utilise `Docker` en local, le *tag* importe peu. On verra par la suite que la structure du *tag* a de l'importance lorsque l'on souhaite [exporter](#imp-docker) ou [importer](#exp-docker) une image `Docker` √† partir d'un d√©p√¥t distant.

[^windows]: Si vous √™tes sur Windows, les lignes de commande disponibles par d√©faut (`cmd` ou `Powershell`) sont peu pratiques. Il est recommand√© d'utiliser la ligne de commande de `Git Bash` (une √©mulation minimaliste d'une ligne de commande `Linux`) qui vous permettra de faire des op√©rations en ligne de commande.

Regardons ce qui se passe en pratique lorsque l'on essaie de construire notre image. Le tag de celle-ci est `myflaskapp`:

```{.bash filename="terminal"}
docker build -t myflaskapp .
```

```{.python}
Sending build context to Docker daemon     47MB
Step 1/8 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/8 : RUN apt-get update && apt-get install -y python3-pip python3-dev
 ---> Running in 92b42d579cfa
...
done.
Removing intermediate container 92b42d579cfa
 ---> 8826d53e3c01
Step 3/8 : WORKDIR /app
 ---> Running in 153b32893c23
Removing intermediate container 153b32893c23
 ---> 7b4d22021986
Step 4/8 : COPY requirements.txt /app/requirements.txt
...
Successfully built 125bd8da70ff
Successfully tagged myflaskapp:latest
```



Le moteur `Docker` essaie de construire notre image s√©quentiellement √† partir des commandes sp√©cifi√©es dans le `Dockerfile`. S'il rencontre une erreur, la proc√©dure s'arr√™te, et il faut alors trouver la source du probl√®me dans les *logs* et adapter le `Dockerfile` en cons√©quence.

Si tout se passe bien, `Docker` nous indique que le *build* a r√©ussi et l'image est pr√™te √† √™tre utilis√©e. On peut v√©rifier que l'image est bien disponible √† l'aide de la commande `docker images`.

```{.bash filename="terminal"}
docker images
```

```{.python}
REPOSITORY                               TAG       IMAGE ID       CREATED          SIZE
myflaskapp                               latest    57d2f410a631   2 hours ago      433MB
```

Int√©ressons nous un peu plus en d√©tail aux *logs* de l'√©tape de *build* üëÜÔ∏è.

Entre les √©tapes, `Docker` affiche des suites de lettres et de chiffres un peu √©sot√©riques, et nous parle de conteneurs interm√©diaires. En fait, il faut voir une image `Docker` comme un empilement de couches (*layers*), qui sont elles-m√™mes des images `Docker`. Quand on h√©rite d'une image avec l'instruction `FROM`, on sp√©cifie donc √† `Docker` la couche initiale, sur laquelle il va construire le reste de notre environnement. A chaque √©tape sa nouvelle couche, et √† chaque couche son *hash*, un identifiant unique fait de lettres et de chiffres.

Cela peut ressembler √† des d√©tails techniques, mais c'est en fait extr√™mement utile en pratique car cela permet √† `Docker` de faire du *caching*. Lorsqu'on d√©veloppe un `Dockerfile`, il est fr√©quent de devoir modifier ce dernier de nombreuses fois avant de trouver la bonne recette, et on aimerait bien ne pas avoir √† *rebuild* l'environnement complet √† chaque fois. `Docker` g√®re cela tr√®s bien : il *cache* chacune des couches interm√©diaires[^cacheCI].

Par exemple, si l'on modifie la 5√®me commande du `Dockerfile`, `Docker` va utiliser le cache pour ne pas avoir √† recalculer les √©tapes pr√©c√©dentes, qui n'ont pas chang√©. Cela s'appelle l'_"invalidation du cache"_ :
d√®s lors qu'une √©tape du `Dockerfile` est modifi√©e, `Docker` va recalculer toutes les √©tapes suivantes, mais seulement celles-ci. Cons√©quence directe de cette observation : il faut toujours ordonner les √©tapes d'un `Dockerfile` de sorte √† ce qui est le plus susceptible d'√™tre souvent modifi√© soit √† la fin du fichier, et inversement.

[^cacheCI]: Le _cache_ est tr√®s pratique pour une construction exp√©rimentale en local. Malheureusement, lorsqu'on passe par des services d'int√©gration continue, l'utilisation du _cache_ est moins √©vidente car chaque `run` se fait sur une machine ind√©pendante de la pr√©c√©dente.

Pour illustrer cela, regardons ce qui se passe si l'on modifie le nom du script qui lance l'application, et donc la valeur de la variable d'environnement `FLASK_APP` dans le `Dockerfile`.

```{.bash filename="terminal"}
docker build . -t myflaskapp
```

```{.python}
Sending build context to Docker daemon  4.096kB
Step 1/10 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/10 : ENV DEBIAN_FRONTEND=noninteractive
 ---> Using cache
 ---> ea1c7c083ac9
Step 3/10 : RUN apt-get update -y &&     apt-get install -y python3-pip python3-dev
 ---> Using cache
 ---> 078b8ac0e1cb
Step 4/10 : WORKDIR /app
 ---> Using cache
 ---> cd19632825b3
Step 5/10 : COPY requirements.txt /app/requirements.txt
 ---> Using cache
 ---> 271cd1686899
Step 6/10 : RUN pip install -r requirements.txt
 ---> Using cache
 ---> 3ea406fdf383
Step 7/10 : COPY . /app
 ---> 3ce5bd3a9572
Step 8/10 : ENV FLASK_APP="new.py"
 ---> Running in b378d16bb605
Removing intermediate container b378d16bb605
 ---> e1f50490287b
Step 9/10 : EXPOSE 5000
 ---> Running in ab53c461d3de
Removing intermediate container ab53c461d3de
 ---> 0b86eca40a80
Step 10/10 : CMD ["flask", "run", "--host=0.0.0.0"]
 ---> Running in 340eec151a51
Removing intermediate container 340eec151a51
 ---> 16d7a5b8db28
Successfully built 16d7a5b8db28
Successfully tagged myflaskapp:latest
```

L'√©tape de *build* a pris quelques secondes au lieu de plusieurs minutes, et les *logs* montrent bien l'utilisation du cache faite par `Docker` : les √©tapes pr√©c√©dant le changement r√©utilisent les couches cach√©es, mais celle d'apr√®s sont recalcul√©es.

## Ex√©cuter (_run_) une image `Docker` {#execution}

L'√©tape de *build* a permis de cr√©er une *image* `Docker`. Une image doit √™tre vue comme un *template* : elle permet d'ex√©cuter l'application sur n'importe quel environnement d'ex√©cution sur lequel un moteur `Docker` est install√©.

En l'√©tat, on a donc juste *construit*, mais rien *lanc√©* : notre application ne tourne pas encore. Pour cela, il faut cr√©er un *conteneur*, i.e. une instance vivante de l'image qui permet d'acc√©der √† l'application. Cela se fait via la commande `docker run`.

```{.bash filename="terminal" no-prefix=true}
$ docker run -d -p 8000:5000 myflaskapp:latest
6a2ab0d82d051a3829b182ede7b9152f7b692117d63fa013e7dfe6232f1b9e81
```

D√©taillons la syntaxe de cette commande :

- `docker run tag` : lance l'image dont on fournit le *tag*. Le *tag* est de la forme `repository/projet:version`. Ici, il n'y a pas de *repository* puisque tout est fait en local ;
- `-d` : "d√©tache" le conteneur du terminal qui le lance ;
- `-p` : effectue un *mapping* entre un port de la machine qui ex√©cute le conteneur, et le conteneur lui-m√™me. Notre conteneur √©coute sur le port 5000, et l'on veut que notre application soit expos√©e sur le port 8000 de notre machine.

Lorsque l'on ex√©cute `docker run`, `Docker` nous r√©pond simplement un *hash* qui identifie le conteneur que l'on a lanc√©. On peut v√©rifier qu'il tourne bien avec la commande `docker ps`, qui renvoie toutes les informations associ√©es au conteneur.

```{.bash filename="terminal"}
docker ps
```

```{.python}
CONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS         PORTS                                   NAMES
6a2ab0d82d05   myflaskapp   "flask run --host=0.‚Ä¶"   7 seconds ago   Up 6 seconds   0.0.0.0:8000->5000/tcp, :::8000->5000/tcp   vigorous_kalam
```

Les conteneurs peuvent √™tre utilis√©s pour r√©aliser des t√¢ches tr√®s diff√©rentes. Grossi√®rement, on peut distinguer deux situations :

- le conteneur effectue une t√¢che "one-shot", c'est √† dire une op√©ration qui a vocation √† s'effectuer en un certain temps, suite √† quoi le conteneur peut s'arr√™ter ;
- le conteneur ex√©cute une application. Dans ce cas, on souhaite que le conteneur reste en vie aussi longtemps que l'on souhaite utiliser l'application en question.

Dans notre cas d'application, on se situe dans la seconde configuration puisque l'on veut ex√©cuter une application web. Lorsque l'application tourne, elle expose sur le *localhost*, accessible depuis un navigateur web ‚Äî en l'occurence, √† l'adresse [localhost:5000/](localhost:5000/). Les calculs sont effectu√©s sur un serveur local, et le navigateur sert d'interface avec l'utilisateur ‚Äî comme lorsque vous utilisez un _notebook_ `Jupyter` par exemple.

Finalement, on a pu d√©velopper et ex√©cuter une application compl√®te sur notre environnement local, sans avoir eu √† installer quoi que ce soit sur notre machine personnelle, √† part `Docker.`


::::

:::: {.content-visible when-profile="en"}

## Building a Docker Image {#build}

To build an image from a `Dockerfile`, use the `docker build` command from the terminal[^windows]. Two important arguments must be provided:

- the **build context**: this tells Docker where the project is located (it should contain the `Dockerfile`). The simplest approach is to navigate into the project directory via `cd` and pass `.` to indicate "build from here";
- the **tag**, i.e., the name of the image. While working locally, the tag doesn‚Äôt matter much, but we‚Äôll see later that it becomes important when [exporting](#imp-docker) or [importing](#exp-docker) an image from/to a remote repository.

[^windows]: On Windows, the default command lines (`cmd` or `PowerShell`) are not very convenient. We recommend using the `Git Bash` terminal, a lightweight Linux command-line emulator, for better compatibility with command-line operations.

Let‚Äôs see what happens when we try to build our image with the tag `myflaskapp`:

```{.bash filename="terminal"}
docker build -t myflaskapp .
```

```{.python}
Sending build context to Docker daemon     47MB
Step 1/8 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/8 : RUN apt-get update && apt-get install -y python3-pip python3-dev
 ---> Running in 92b42d579cfa
...
done.
Removing intermediate container 92b42d579cfa
 ---> 8826d53e3c01
...
Successfully built 125bd8da70ff
Successfully tagged myflaskapp:latest
```

Docker‚Äôs engine processes the instructions from the `Dockerfile` one at a time. If there‚Äôs an error, the build stops, and you‚Äôll need to debug the problem using the log output and adjust the `Dockerfile` accordingly.

If successful, Docker will indicate that the build was completed and that the image is ready for use. You can confirm its presence with the `docker images` command:

```{.bash filename="terminal"}
docker images
```

```{.python}
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
myflaskapp   latest    57d2f410a631   2 hours ago      433MB
```

Let‚Äôs look more closely at the build logs üëÜÔ∏è.

Between each step, Docker prints cryptic hashes and mentions intermediate containers. Think of a Docker image as a stack of **layers**, each layer being itself a Docker image. The `FROM` instruction specifies the starting layer. Each command adds a new layer with a unique hash.

This design is not just technical trivia‚Äîit‚Äôs incredibly useful in practice because Docker **caches** each intermediate layer[^cacheCI].

For example, if you modify the 5th instruction in the `Dockerfile`, Docker will reuse the cache for previous layers and only rebuild from the change onward. This is called **cache invalidation**: once a step changes, Docker recalculates that step and all that follow, but no more. As a result, you should always place frequently changing steps at the end of the file.

[^cacheCI]: Caching is very useful for local development. Unfortunately, it‚Äôs harder to leverage in CI environments, since each run usually happens on a fresh machine.

Let‚Äôs illustrate this by changing the `FLASK_APP` environment variable in the `Dockerfile`:

```{.bash filename="terminal"}
docker build . -t myflaskapp
```

```{.python}
Sending build context to Docker daemon  4.096kB
Step 1/10 : FROM ubuntu:20.04
 ---> 825d55fb6340
Step 2/10 : ENV DEBIAN_FRONTEND=noninteractive
 ---> Using cache
 ---> ea1c7c083ac9
Step 3/10 : RUN apt-get update -y && ...
 ---> Using cache
 ---> 078b8ac0e1cb
...
Step 8/10 : ENV FLASK_APP="new.py"
 ---> Running in b378d16bb605
...
Successfully built 16d7a5b8db28
Successfully tagged myflaskapp:latest
```

The build finishes in seconds instead of minutes. The logs show that previous steps were cached, and only modified or dependent ones were rebuilt.

## Running a Docker Image {#execution}

The `build` step created a **Docker image**‚Äîessentially a blueprint for your app. It can be executed on any environment with Docker installed.

So far, we‚Äôve built the image but haven‚Äôt **run** it. To launch the app, we must create a **container**, i.e., a live instance of the image. This is done with the `docker run` command:

```{.bash filename="terminal" no-prefix=true}
$ docker run -d -p 8000:5000 myflaskapp:latest
6a2ab0d82d051a3829b182ede7b9152f7b692117d63fa013e7dfe6232f1b9e81
```

Here‚Äôs a breakdown of the command:

- `docker run tag`: runs the image specified by `tag`. Tags usually follow the format `repository/project:version`. Since we're local, there's no repository;
- `-d`: runs the container in **detached** mode (in the background);
- `-p`: maps a port on the host machine (8000) to a port inside the container (5000). Since Flask listens on port 5000, this makes the app accessible via `localhost:8000`.

The command returns a long hash‚Äîthis is the container ID. You can verify that it‚Äôs running with:

```{.bash filename="terminal"}
docker ps
```

```{.python}
CONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS         PORTS                                   NAMES
6a2ab0d82d05   myflaskapp   "flask run --host=0.‚Ä¶"   7 seconds ago   Up 6 seconds   0.0.0.0:8000->5000/tcp, :::8000->5000/tcp   vigorous_kalam
```

Docker containers serve different purposes. Broadly, they fall into two categories:

- **One-shot jobs**: containers that execute a task and terminate;
- **Running apps**: containers that persist while serving an application.

In our case, we‚Äôre in the second category. We want to run a web app, so the container must stay alive. Flask launches a server on a local port (5000), and we‚Äôve mapped it to port 8000 on our machine. You can access the app from your browser at [localhost:8000](http://localhost:8000/), just like a Jupyter notebook.

In the end, we‚Äôve built and launched a fully working application on our local machine‚Äîwithout installing anything beyond Docker itself.

::::