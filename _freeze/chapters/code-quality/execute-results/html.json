{
  "hash": "ba09a038677600d993d164299fded89a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Am√©liorer la qualit√© de son code\"\ndescription: |\n  Pr√©sentation des standards permettant de produire du code lisible et maintenable, et d'outils pour faciliter leur adoption.\nimage: images/snake.png\norder: 2\nhref: chapters/code-quality.html\n---\n\n<details>\n<summary>\nD√©rouler les _slides_ ci-dessous ou [cliquer ici](https://ensae-reproductibilite.github.io/slides/#/qualit√©-du-code)\npour afficher les slides en plein √©cran.\n</summary>\n\n\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode yaml code-with-copy\"><code class=\"sourceCode yaml\"></code><button title=\"Copy to Clipboard\" class=\"code-copy-button\"><i class=\"bi\"></i></button></pre><iframe class=\"sourceCode yaml code-with-copy\" src=\"https://ensae-reproductibilite.github.io/slides/#/qualit√©-du-code\"></iframe></div>\n\n</details>\n\nCe chapitre constitue une introduction √† la question de la qualit√© du code, \npremier niveau dans l'√©chelle des bonnes pratiques. Celui-ci pr√©sente\nles enjeux de la qualit√© du code, les principes g√©n√©raux pour am√©liorer\ncelui-ci et quelques outils ou gestes faciles √† mettre en ≈ìuvre\npour am√©liorer la qualit√© du code. Ceux-ci sont approfondis dans\nl'[application fil rouge](/chapters/application.qmd). \n \n\n# Introduction\n\n![Image emprunt√©e √† la page \"Les joies du code\"](/berk.png){fig-align=\"center\"}\n\n## L'enjeu d'un code lisible et maintenable\n\n> _\"The code is read much more often than it is written.\"_\n>\n> Guido Van Rossum[^1]\n\n[^1]: Guido Van Rossum est le cr√©ateur de {{< fa brands python >}}, c'est donc quelqu'un qu'il est pertinent d'√©couter.\n\nLorsqu'on s'initie √† la pratique de la *data science*, il est assez naturel de voir le code d'une mani√®re tr√®s fonctionnelle : je veux r√©aliser une t√¢che donn√©e ‚Äî par exemple un algorithme de classification ‚Äî et je vais donc assembler dans un *notebook* des bouts de code, souvent trouv√©s sur internet, jusqu'√† obtenir un projet qui r√©alise la t√¢che voulue. La structure du projet importe assez peu, tant qu'elle permet d'importer correctement les donn√©es n√©cessaires √† la t√¢che en question.\n\nSi cette approche flexible et minimaliste fonctionne tr√®s bien lors de la phase d'apprentissage, il est malgr√© tout indispensable de s'en d√©tacher progressivement √† mesure que l'on progresse et que l'on est amen√© √† r√©aliser des projets plus professionnels ou bien √† int√©grer des projets collaboratifs. Autrement, on risque de __produire un code complexe √† reprendre et √† faire √©voluer, ce qui pourrait conduire in√©vitablement √† son abandon__.\n\nEn particulier, il est important de proposer, parmi les multiples mani√®res de r√©soudre un probl√®me informatique, une solution qui soit intelligible par d'autres personnes parlant le m√™me langage. Le code est en effet lu bien plus souvent qu'il n'est √©crit, c'est donc avant tout un __outil de communication__. De m√™me, la maintenance d'un code demande g√©n√©ralement beaucoup plus de moyens que sa phase de d√©veloppement initial. Il est donc important de penser en amont la qualit√© de son code et la structure de son projet de sorte √† le rendre maintenable dans le temps.\n\nAfin de faciliter la communication et r√©duire la douleur d'avoir √† faire √©voluer un code obscur, des tentatives plus ou moins institutionnalis√©es de d√©finir des conventions ont √©merg√©. Ces conventions d√©pendent naturellement du langage utilis√©, mais les principes sous-jacents s'appliquent de mani√®re universelle √† tout projet bas√© sur du code.\n\n\n## De l'importance de suivre les conventions\n\n`Python` est un langage tr√®s __lisible__.\nAvec un peu d‚Äôeffort sur le nom des objets,\nsur la gestion des d√©pendances et sur la structure du programme,\non peut tr√®s bien comprendre un script sans avoir besoin de l‚Äôex√©cuter.\nC'est l'une des principales forces du langage `Python` qui permet ainsi\nune acquisition rapide des bases et facilite l'appropriation d'un script.\n\nLa communaut√© `Python` a abouti √† un certain nombre de normes,\ndites `PEP` (_Python Enhancement Proposal_),\nqui constituent un standard dans l‚Äô√©cosyst√®me Python.\nLes deux normes les plus connues sont :\n\n- la __norme [`PEP8`](https://peps.python.org/pep-0008/)__ qui d√©finit un certain nombre de conventions\nrelatives au code ;\n- la __norme [`PEP257`](https://peps.python.org/pep-0257/)__ consacr√©e √† la documentation (_docstrings_).\n\nCes conventions vont au-del√† de la syntaxe. Un certain nombre de standards\nd'organisation d'un projet ont √©merg√©, qui seront abord√©es\ndans le [prochain chapitre](/chapters/projects-architecture.html). \n\n::: {.callout-note collapse=\"true\"}\n## Comparaison avec {{< fa brands r-project >}} \n\nDans l'univers {{< fa brands r-project >}}, la formalisation\na √©t√© moins organis√©e. Ce langage est plus permissif que `Python`\nsur certains aspects[^2]. N√©anmoins, des standards ont √©merg√© r√©cemment, √† travers\nun certain nombre de _style guides_ dont les plus connus\nsont le\n[_tidyverse style guide_](https://style.tidyverse.org/googl) et le\n[_google style guide_](https://google.github.io/styleguide/Rguide.html), [MLR style guide](https://github.com/mlr-org/mlr3/wiki/Style-Guide#theoretical-style-guide)...\n\nPour aller plus loin sur {{< fa brands r-project >}}:\n\n* La formation Insee [aux bonnes pratiques avec `Git` et {{< fa brands r-project >}}](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/) dont le parcours est tr√®s proche de celui de ce cours ; \n* Des √©l√©ments compl√©mentaires dans la [documentation collaborative `utilitR`](https://www.book.utilitr.org/02_bonnes_pratiques/01-qualite-code) ;\n* [Ce post](https://blog.r-hub.io/2022/03/21/code-style/) qui pointe vers\nun certain nombre de ressources sur le sujet.\n:::\n\n[^2]: Par exemple, en {{< fa brands r-project >}}, il est possible d'utiliser `<-` ou `=`\npour l'assignation,\non ne recontre pas d'erreur en cas de mauvaise indentation...\n\nCes conventions sont arbitraires, dans une certaine mesure. Il est tout √† fait\npossible de trouver certaines conventions moins esth√©tiques que d'autres. \n\nCes conventions ne sont pas non plus immuables : les langages et leurs usages\n√©voluent, ce qui n√©cessite de mettre √† jour les conventions. Cependant,\nadopter dans la mesure du possible certains des r√©flexes pr√©conis√©s par ces\nconventions devrait am√©liorer la capacit√© √† √™tre compris par la communaut√©,\naugmenter les chances de \nb√©n√©ficier d'apport de celle-ci pour adapter le code, mais aussi r√©duire la \ndifficult√© √† faire √©voluer un code.\n\nIl existe beaucoup de philosophies diff√©rentes sur le style de codage et,\nen fait, le plus important est\nla __coh√©rence__ :\nsi on choisit une convention, par exemple _snake case_ (`toto_a_la_plage`) plut√¥t que\n_camel case_ (`totoALaPlage`), le mieux est de s'y tenir. \n\n\n# Principe 1Ô∏è‚É£ : Adopter les standards communautaires\n\nDans la lign√©e de la vision des bonnes pratiques comme\ncontinuum propos√©e en [introduction](/chapters/introduction.qmd), il n'est pas n√©cessairement souhaitable d'appliquer toutes les recommandations pr√©sent√©es dans ce chapitre √† chaque projet. Sur certains projets, le co√ªt marginal\nd'adopter certaines pratiques peut exc√©der les b√©n√©fices induits. \nNous recommandons plut√¥t de voir ces bonnes pratiques comme de bonnes habitudes √† acqu√©rir en op√©rant un va-et-vient r√©gulier entre la pratique et la th√©orie. Les outils\nque nous allons proposer seront l√† pour acc√©l√©rer la mise en ≈ìuvre des bonnes pratiques.\n\nLes √©l√©ments expos√©s dans ce chapitre n'ont pas vocation √† √™tre exhaustifs.\nIls visent √† pointer vers quelques ressources utiles tout en proposant des conseils pratiques.\nL'apprentissage par c≈ìur de ces r√®gles ou\nfaire des aller-retour en continu entre le code\net les manuels de r√®gles \nserait quelques\npeu r√©barbatif.\n\nPour faire le parall√®le avec\nle langage naturel, on n'a pas toujours le bescherelle \nou le dictionnaire sous les yeux. Les √©diteurs de \ntexte ou les smartphones embarquent des correcteurs\northographiques qui identifient, voire corrigent\ndirectement le texte √©crit. \n\n## Un bon IDE, un premier pas vers la qualit√©\n\nSans les outils automatis√©s de mise en forme du code, l'adoption des bonnes\npratiques serait co√ªteuse en temps et donc difficile √† mettre en ≈ìuvre\nau quotidien. Ces outils, que ce soit par le biais de diagnostics ou de\nmise aux normes automatis√©e du code\nrendent de pr√©cieux services. Adopter les standards minimaux de qualit√©\nest plus ou moins instantan√© et √©conomise un temps pr√©cieux dans la vie\nd'un projet de _data science_. C'est un pr√©alable indispensable √† la \nmise en production, sur laquelle nous reviendrons ult√©rieurement. \n\n\nLe premier pas vers les bonnes pratiques est d'adopter un environnement de d√©veloppement\nadapt√©. `VSCode` est un tr√®s bon environnement comme nous le d√©couvrirons\ndans la [partie pratique](/chapters/application.qmd). Il propose tous les\noutils d'autocompl√©tion et de diagnostics usuels (contrairement \n√† `Jupyter`) et propose une grande gamme d'extensions pour enrichir\nles fonctionnalit√©s de l'IDE de mani√®re contributive :\n\n![Exemple de diagnostics et d'actions propos√©s par `VSCode`](https://code.visualstudio.com/assets/docs/python/editing/packageAbbreviations.gif)\n\nN√©anmoins, les outils de d√©tection de code au niveau des IDE\nne suffisent pas. En effet, ils n√©cessitent une composante manuelle\nqui peut √™tre chronophage et ainsi p√©nible √† appliquer\nr√©guli√®rement. Heureusement, il existe des outils automatis√©s de diagnostics\net de mise en forme. \n\n\n\n### Les outils automatis√©s pour le diagnostic et la mise en forme du code \n\n`Python` √©tant l'outil de travail principal de milliers de \n_data-scientists_, un certain nombre d'outils ont vu le jour\npour r√©duire le temps n√©cessaire pour cr√©er un projet ou disposer\nd'un code fonctionnel. Ces outils permettent un gros gain de productivit√©,\nr√©duisent le temps pass√© √† effectuer des t√¢ches r√©barbatives et am√©liorent\nla qualit√© d'un projet en offrant des diagnostics, voire des correctifs\n√† des codes perfectibles. \n\nLes deux principaux types d'outils sont les suivants :\n\n1. **_Linter_** : programme qui v√©rifie que le code est __formellement__ conforme √† un certain _guidestyle_\n    + signale des probl√®mes formels, sans corriger \n2. **_Formatter_** : programme qui reformate un code pour le rendre conforme √† un certain _guidestyle_\n    + modifie directement le code\n\n\n::: {.callout-tip collapse=\"true\"}\n## Exemples\n\n- Exemples d‚Äôerreurs rep√©r√©es par un _linter_ : \n    + lignes de code trop longues ou mal indent√©es, parenth√®ses non √©quilibr√©es, noms de fonctions mal construits‚Ä¶\n- Exemples d‚Äôerreurs __non__ rep√©r√©es par un _linter_ :\n    + fonctions mal utilis√©es, arguments mal sp√©cifi√©s, structure du code incoh√©rente, code insuffisamment document√©‚Ä¶\n:::\n\n\n### Les _linters_ pour comprendre les mauvaises pratiques appliqu√©es\n\nLes _linters_ sont des outils qui permettent d'√©valuer la qualit√© du \ncode et son risque de provoquer une erreur (explicite ou silencieuse).\n\nVoici quelques exemples de probl√®mes que peuvent rencontrer les \n`linters`:\n\n* les variables sont utilis√©es mais n'existent pas (erreur)\n* les variables inutilis√©es (inutiles)\n* la mauvaise organisation du code (risque d'erreur)\n* le non-respect des bonnes pratiques d'√©criture de code\n* les erreurs de syntaxe (par exemple les coquilles)\n    \nLa plupart des logiciels de d√©veloppement embarquent des fonctionnalit√©s\nde diagnostic (voire de suggestion de correctif). Il faut parfois\nles param√©trer dans les options (ils sont d√©sactiv√©s pour ne pas\neffrayer l'utilisateur avec des croix rouges partout).\nN√©anmoins, si on n'a pas appliqu√© les correctifs\nau fil de l'eau la masse des modifications √† mettre en \n≈ìuvre peut √™tre effrayante. \n\nEn `Python`, les deux principaux _linters_\nsont [`PyLint`](https://pylint.readthedocs.io/en/latest/) et\n[`Flake8`](https://flake8.pycqa.org/en/latest/). \nDans les exercices, nous proposons d'utiliser `PyLint` qui est\npratique et p√©dagogique. Celui-ci s'utilise en ligne de commande,\nde la mani√®re suivante :\n\n```{.bash}\npip install pylint\npylint monscript.py #pour un fichier\npylint src #pour tous les fichiers du dossier src\n```\n\n\n::: {.callout-tip collapse=\"true\"}\n\nL'un des int√©r√™ts d'utiliser `PyLint` est qu'on obtient une note,\nce qui est assez instructif. Nous l'utiliserons dans l'application\nfil rouge pour comprendre la mani√®re dont chaque √©tape am√©liore\nla qualit√© du code. \n\nIl est possible de mettre en ≈ìuvre des [_pre commit hooks_](https://pylint.readthedocs.io/en/latest/user_guide/installation/pre-commit-integration.html) qui emp√™chent un\n_commit_ n'ayant pas une note minimale. \n\n:::\n\n### Les _formatters_ pour nettoyer en masse ses scripts \n\nLe _formatter_ modifie directement le code. On peut\nfaire un parall√®le avec le correcteur orthographique.\nCet outil peut\ndonc induire un changement substantiel du script\nafin de le rendre plus lisible.\n\nLe _formater_ le plus utilis√©\n\nest [`Black`](https://black.readthedocs.io/en/stable/). \nR√©cemment, [`Ruff`](https://github.com/astral-sh/ruff),\nqui est √† la fois un _linter_ et un _formatter_\na √©merg√© pour int√©grer √† `Black` des diagnostics\nsuppl√©mentaires, issus d'autres _packages_.\n\n::: {.callout-note collapse=\"true\"}\n\nPour signaler sur `Github`\nla qualit√© d'un projet utilisant `Black`, il est possible\nd'ajouter un badge dans le `README`:\n\n[![](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\n:::\n\n\nIl est assez instructif de regarder\nle code modifi√© par les outils pour comprendre et corriger certains probl√®mes dans sa mani√®re de d√©velopper. \nPar exemple, √† la lecture de ce chapitre, vous allez certainement retenir en particulier certaines r√®gles qui tranchent avec vos pratiques actuelles. Vous pouvez alors essayer d'appliquer ces nouvelles r√®gles pendant un certain temps puis, lorsque celles-ci seront devenues naturelles, revenir √† ce guide et appliquer le processus √† nouveau. En proc√©dant ainsi de mani√®re incr√©mentale, vous am√©liorerez progressivement la qualit√© de vos projets sans avoir l'impression de passer trop de temps sur des micro-d√©tails, au d√©triment des objectifs globaux du projet.\n\n## Le partage, une d√©marche favorable √† la qualit√© du code\n\n### L'_opensource_ comme moyen pour am√©liorer la qualit√©\n\nEn ouvrant son code sur des forges _opensource_ (cf. [chapitre `Git`](/chapters/git.qmd)), il est possible de recevoir\ndes suggestions voire, des contributions de r√©-utilisateurs\ndu code. Cependant, les vertus de l'ouverture vont au-del√†.\nEn effet, l'ouverture se traduit g√©n√©ralement par des codes de \nmeilleure qualit√©, mieux document√©s pour pouvoir √™tre r√©utilis√©s\nou ayant simplement b√©n√©fici√© d'une attention accrue sur la qualit√©\npour ne pas para√Ætre ridicule. M√™me en l'absence de retour de (r√©)utilisateurs\ndu code, le partage de code am√©liore la qualit√© des projets. \n\n### La revue de code\n\nLa revue de code s'inspire de la m√©thode du _peer reviewing_ du monde acad√©mique\npour am√©liorer la qualit√© du code `Python`. Dans une revue de code, \nle code √©crit par une personne est relu et √©valu√© par un ou plusieurs autres d√©veloppeurs\nafin d'identifier les erreurs et les am√©liorations possibles.\nCette pratique permet de d√©tecter les erreurs avant qu'elles ne deviennent des probl√®mes majeurs,\nd'assurer une coh√©rence dans le code, de garantir le respect des bonnes pratiques\nmais aussi d'am√©liorer la qualit√© du code en identifiant les parties du code qui peuvent √™tre simplifi√©es, optimis√©es ou refactoris√©es pour en am√©liorer la lisibilit√© et la maintenabilit√©.\n\nUn autre avantage de cette approche est qu'elle permet le \npartage de connaissances entre des personnes exp√©riment√©es et des personnes\nplus d√©butantes ce qui permet √† ces derni√®res de monter en comp√©tence.\n`Github` {{< fa brands github >}} et `Gitlab` {{< fa brands gitlab >}}\nproposent des fonctionnalit√©s tr√®s pratiques\npour la revue de code : discussions, suggestions de modifications...\n\n\n# Principe 2Ô∏è‚É£ : favoriser une structure modulaire\n\n## Objectifs\n\n- Favoriser la __concision__ pour r√©duire le risque d'erreur\net rendre la d√©marche plus claire ;\n- Am√©liorer la __lisibilit√©__ ce qui est indispensable pour\nrendre la d√©marche intelligible par d'autres mais aussi pour soi, lorsqu'on\nreprend un code √©crit il y a quelques temps ;\n- Limiter la __redondance__ ce qui permet de simplifier\nun code (paradigme du _don't repeat yourself_) ;\n- Limite les risques d‚Äô__erreurs li√©es aux copier/coller__\n\n## Avantages des fonctions\n\nLes fonctions ont de nombreux avantages par rapport √† de longs\nscripts :\n\n- Limite les risques d'erreurs li√©s aux copier/coller\n- Rend le code plus lisible et plus compact\n- Un seul endroit du code √† modifier lorsqu'on souhaite modifier le traitement\n- Facilite la r√©utilisation et la documentation du code !\n\n::: {.callout-important}\n## R√®gle d'or\n\nIl faut utiliser une [**fonction**]{.red2} d√®s qu'on utilise une m√™me\nportion de code plus de deux fois ([**_don't repeat yourself_ (DRY)**]{.red2})\n:::\n\n\n::: {.callout-tip}\n## R√®gles pour √©crire des fonctions **pertinentes**\n\n- Une t√¢che = une fonction\n- Une t√¢che complexe = un encha√Ænement de fonctions r√©alisant chacune une t√¢che simple\n- Limiter l'utilisation de variables globales\n\n:::\n\nEn ce qui concerne l'installation des packages, nous allons voir\ndans les parties [Structure de code](/chapters/projects-architecture.html) et [Portabilit√©](/chapters/portability.qmd)\nqu'il ne faut pas\ng√©rer ceci dans le script mais dans un √©l√©ment √† part, relatif √† l'environnement \nd'ex√©cution du projet[^environnement]. De m√™me, ces parties pr√©senteront\ndes conseils pratiques sur la gestion des jetons d'acc√®s √† des API ou bases de donn√©es\nqui ne __doivent jamais √™tre inscrites dans un code__. \n\n[^environnement]: Nous pr√©senterons les deux approches principales en `Python`,\n        leurs points commun et les points par lesquels ils diff√®rent : \n        les environnements virtuels (g√©r√©s par un fichier `requirements.txt`)\n        et les environnements conda (g√©r√©s par un fichier `environment.yml`)\n\n\nLes scripts trop longs ne sont pas une bonne pratique. Il est pr√©f√©rable\nde diviser l'ensemble des scripts ex√©cutant une\ncha√Æne de production en _\"monades\"_, c'est-√†-dire en petites unit√©s\ncoh√©rentes. Les fonctions sont un outil privil√©gi√© pour cela\n(en plus de limiter la redondance, et d'√™tre un outil privil√©gi√©\npour documenter un code).\n\n\n::: {.callout-caution collapse=\"true\"}\n## Exemple: privil√©gier les _list comprehensions_\n\nEn `Python`, il est recommand√© de privil√©gier\nles _list comprehensions_ √† l'utilisation de boucles\n`for` indent√©es. Ces derni√®res sont en g√©n√©ral moins\nefficaces et surtout impliquent un nombre important de \nligne de codes l√† o√π les compr√©hensions de listes sont\nbeaucoup plus concises\n\n```python\nliste_nombres = range(10)\n\n# tr√®s mauvais\ny = []\nfor x in liste_nombres:\n    if x % 2 == 0:\n        y.append(x*x)\n\n# mieux\ny = [x*x for x in liste_nombres if x % 2 == 0]\n```\n\n\n:::\n\n\n### Conseils pour la programmation\n\nDans le monde de la programmation en `Python`, il existe deux paradigmes\ndiff√©rents :\n\n* La __programmation fonctionnelle__ est une approche qui construit un \ncode en encha√Ænant des fonctions, c'est-√†-dire des op√©rations plus ou\nmoins standardis√©es ; \n* La __programmation orient√©e objet (POO)__ consiste\n√† construire son code en d√©finissant des objets\nd'une certaine _classe_ ayant des\n_attributs_ (les caract√©ristiques intrins√®ques de l'objet)\net sur lequel on effectue des op√©rations _ad hoc_ par le biais\nde _m√©thodes_ qui encapsulent des op√©rations propres √†\nchaque classe. \n\n\n<details>\n\n<summary>\nExemple de comparaison des deux paradigmes\n</summary>\n\nMerci _ChatGPT_ pour l'exemple :\n\n::: {#38e975f3 .cell execution_count=1}\n``` {.python .cell-code}\nclass AverageCalculator:\n    def __init__(self, numbers):\n        self.numbers = numbers\n\n    def calculate_average(self):\n        return sum(self.numbers) / len(self.numbers)\n\n# Utilisation\ncalculator = AverageCalculator([1, 2, 3, 4, 5])\nprint(\"Moyenne (POO):\", calculator.calculate_average())\n\ndef calculate_average(numbers):\n    return sum(numbers) / len(numbers)\n\n# Utilisation\nnumbers = [1, 2, 3, 4, 5]\nprint(\"Moyenne (PF):\", calculate_average(numbers))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMoyenne (POO): 3.0\nMoyenne (PF): 3.0\n```\n:::\n:::\n\n\n</details>\n\nLa programmation fonctionnelle est plus intuitive que la\nPOO et permet souvent de d√©velopper du code plus\nrapidement. La POO est une approche plus formaliste.\nCelle-ci est int√©ressante lorsqu'une fonction doit\ns'adapter au type d'objet en entr√©e (par exemple aller chercher des\npoids diff√©rents selon le type de mod√®le [`Pytorch`](https://pytorch.org/vision/0.9/models.html)).\nCela √©vite les codes _spaghetti_ üçù inutilement complexes qui sont impossibles √† d√©bugger.\n\nN√©anmoins, il convient d'√™tre pragmatique. La programmation orient√©e objet peut √™tre\nplus complexe √† mettre en ≈ìuvre que la programmation fonctionnelle. Dans de \nnombreuses situations, cette derni√®re, si elle est bien faite, suffit largement. \nIl est utile lorsqu'on d√©veloppe dans le cadre d'un projet important d'adopter\nune approche dite de __programmation d√©fensive__. Il s'agit d'un principe\nde pr√©caution dans le paradigme de la programmation fonctionnelle qui vise\n√† limiter les\nsituations impr√©vues en √©tant capable\nde g√©rer, par exemple, un argument d'une fonction inattendu ou un objet\n√† la structure diff√©rente de celle pour lequel le code a √©t√© pens√©. \n\n::: {.callout-note}\n\n## Le code spaghetti\n\nLe code `spaghetti` est un style d'√©criture qui favorise l'apparition du syndrome du plat de spaghettis : \nun code impossible √† d√©m√™ler parce qu'il fait un usage excessif de conditions, d'exceptions en tous sens, de gestion des √©v√©nements complexes. Il devient quasi impossible de savoir quelles ont √©t√© les conditions √† l'origine de telle ou telle erreur sans ex√©cuter ligne √† ligne (et celles-ci sont excessivement nombreuses du fait de mauvaises pratiques de programmation) le programme. \n\nEn fait, la programmation spaghetti qualifie tout ce qui ne permet pas de d√©terminer le qui, le quoi et le comment. Le code est donc plus long √† mettre √† jour car cela n√©cessite de remonter un √† un le fil des renvois.\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n\n## Un exemple progressif pour comprendre\n\nüí° Supposons qu'on dispose d'une table de donn√©es qui utilise le code `‚àí99` pour repr√©senter les valeurs manquantes.\nOn d√©sire remplacer l'ensemble des `‚àí99` par des `NA`.\n\nVoici un code `Python` qui permet de se placer dans ce cas qui, malheureusement,\narrive fr√©quemment.\n\n```python\n# On fixe la racine pour √™tre s√ªr de tous avoir le m√™me dataset\nnp.random.seed(1234)\n\n# On cr√©√© un dataframe\na = np.random.randint(1, 10, size = (5,6))\ndf = np.insert(\n    a,\n    np.random.choice(len(a), size=6),\n    -99,\n)\ndf = pd.DataFrame(df.reshape((6,6)), columns=[chr(x) for x in range(97, 103)])\n```\n\n\nUn premier jet de code pourrait prendre la forme suivante :\n\n```python\n# Dupliquer les donn√©es\ndf2 = df.copy()\n# Remplacer les -99 par des NA\ndf2.loc[df2['a'] == -99,'a'] = np.nan\ndf2.loc[df2['b'] == -99,'b'] = np.nan\ndf2.loc[df2['c'] == -99,'c'] = np.nan\ndf2.loc[df2['d'] == -99,'d'] = np.nan\ndf2.loc[df2['e'] == -98,'e'] = np.nan\ndf2.loc[df2['f'] == -99,'e'] = np.nan\n```\n\nQuelles sont les choses qui vous d√©rangent dans le code ci-dessus ?\n\n<details>\n<summary>\nIndice üí° Regardez pr√©cis√©ment le code et le `DataFrame`, notamment les colonnes `e` et `g`.\n</summary>\nIl y a deux erreurs, difficiles √† d√©tecter:\n\n- `df2.loc[df2['e'] == -98,'e'] = np.nan`: une erreur de copier-coller sur la valeur de l'erreur ;\n- `df2.loc[df2['f'] == -99,'e'] = np.nan`: une erreur de copier-coller sur les colonnes en question\n</details>\n\nOn peut noter au moins deux trois :\n\n* Le code est long et r√©p√©titif, ce qui nuit √† sa lisibilit√© ;\n* Le code est tr√®s d√©pendant de la structure des donn√©es (nom et nombre de colonnes) et doit √™tre adapt√© d√®s que celle-ci √©volue ;\n* On a introduit des erreurs humaines dans le code, difficiles √† d√©tecter. \n\nOn voit dans la premi√®re version de notre code qu'il y a une structure commune √† toutes nos lignes de la forme `.[. == -99] = np.nan`. Cette structure va servir de base √† notre fonction, en vue de g√©n√©raliser le traitement que nous voulons faire.\n\n```python\ndef fix_missing(x: pd.Series):\n    x[x == -99] = np.nan\n    return x\n\ndf2 = df.copy()\ndf2['a'] = fix_missing(df['a'])\ndf2['b'] = fix_missing(df['b'])\ndf2['c'] = fix_missing(df['c'])\ndf2['d'] = fix_missing(df['d'])\ndf2['e'] = fix_missing(df['e'])\ndf2['f'] = fix_missing(df['f'])\n```\n\nCette seconde version du code est meilleure que la premi√®re version, car on a r√©gl√© le probl√®me d'erreur humaine (il n'est plus possible de taper `-98` au lieu de `-99`).\n\n<details>\n<summary>\nMais voyez-vous le probl√®me qui persiste ?\n</summary>\n\nLe code reste long et r√©p√©titif, et n'√©limine pas encore toute possibilit√© d'erreur, car il est toujours possible de se tromper dans le nom des variables. \n</details>\n\nLa prochaine √©tape consiste √† √©liminer ce risque d'erreur en combinant deux fonctions (ce qu'on appelle la combinaison de fonctions).\n\nLa premi√®re fonction `fix_missing()` sert √† r√©gler le probl√®me sur un vecteur. La seconde g√©n√©ralisera ce proc√©d√© √† toutes les colonnes. Comme `Pandas` permet une approche vectorielle, il est fr√©quent de construire des fonctions sur des vecteurs et les appliquer ensuite √† plusieurs colonnes.\n\n\n```python\ndef fix_missing(x: pd.Series):\n    x[x == -99] = np.nan\n    return x\n\ndf2 = df.copy()\ndf2 = df2.apply(fix_missing)\n```\n\nCette troisi√®me version du code a plusieurs avantages sur les deux autres versions :\n\n1. Elle est plus concise et plus lisible ;\n2. Si on a un changement de code pour les valeurs manquantes, il suffit de le mettre √† un seul endroit ;\n3. Elle fonctionne quel que soit le nombre de colonnes et le nom des colonnes ;\n4. On ne peut pas traiter une colonne diff√©remment des autres par erreur.\n\nDe plus, le code est facilement g√©n√©ralisable.\n\nPar exemple, √† partir de la m√™me structure, √©crire le code qui permet de ne traiter que les colonnes *a*,*b* et *e*\nne demande pas beaucoup d'√©nergie.\n\n\n```python\ndf2 = df.copy()\ndf2[['a','b','e']] = df2[['a','b','e']].apply(fix_missing)\n```\n:::\n\nUn certain nombre de conseils sont pr√©sents dans le [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/style/)\nqui vise √† faire conna√Ætre les pr√©ceptes du _\"Zen of Python\"_ (PEP 20).\n[Ce post de blog](https://towardsdatascience.com/the-zen-of-python-a-guide-to-pythons-design-principles-93f3f76d088a) illustre quelques uns\nde ces principes avec des exemples.\n\n::: {.callout-note collapse=\"true\"}\n## Le _Zen de Python_\n\nLe _\"Zen de Python\"_ est une collection de principes pour la programmation en `Python`, √©crite par Tim Peters en 2004\nsous la forme d'aphorismes. Ceux-ci\nmettent en lumi√®re la philosophie de conception du langage `Python`.\n\nVous pouvez retrouver ces conseils dans `Python` en \ntapant le code suivant:\n\n:::: {.python}\n\n```python\nimport this\n```\n\n```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```\n\n::::\n\n:::\n\n\n\n# Principe 3Ô∏è‚É£ : (auto)documenter son code\n\nUn code √©crit avec des __noms de variables et de fonctions explicites__ est autant,\nvoire plus, informatif que les commentaires qui l‚Äôaccompagnent.\nC‚Äôest pourquoi il est essentiel de respecter des conventions, et de s'y tenir,\npour le\nchoix des noms des objets afin d‚Äôassurer la lisibilit√© des programmes.\n\nIl est recommand√© de privil√©gier l'__autodocumentation__\n√† la multiplication de commentaires dans un document. Trop de commentaires fait que\nceux-ci ne seront\njamais lus. Ils risquent d'ailleurs de ne pas √™tre actualis√©s en m√™me temps que le code\nqu'ils accompagnent, ce qui est une source d'erreur potentielle.  \nUne documentation est inutile si elle d√©crit ce qui est intelligible\npar ailleurs en lisant le code : il est donc important\nde documenter le pourquoi plut√¥t que le comment. \n\nEn r√©sum√©,\nles deux grands principes de la documentation au sein d'un script sont les suivants :\n\n- Il est pr√©f√©rable de __documenter le pourquoi plut√¥t que le comment__. Le _\"comment\"_ devrait\n√™tre compr√©hensible √† la lecture du code ;\n- Privil√©gier l'autodocumentation via des __nommages pertinents__.\n\n\n::: {.callout-tip}\n## Comment bien documenter un script ?\n\n- **Minimum** üö¶ : commentaire au d√©but du script pour d√©crire ce qu'il fait\n- **Bien** üëç : commenter les parties \"d√©licates\" du code\n- **Id√©al** üí™ : documenter ses fonctions avec la syntaxe des `docstrings`.\n\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Le _type hinting_, un √©l√©ment d'autodocumentation\n\n`Python` propose une fonctionalit√© assez plaisante qui est\nle _`type hinting`_\n([doc officielle](https://docs.python.org/3/library/typing.html)\net [tutoriel sur realpython.com](https://realpython.com/lessons/type-hinting/)).\n\nCette approche permet d'indiquer le type d'argument attendu par une fonction\net celui qui sera renvoy√© par la fonction.\nPar exemple, la personne ayant √©crit la fonction suivante \n\n```python\ndef calcul_moyenne(df: pd.DataFrame, col : str = \"y\") -> pd.DataFrame:\n    return df[col].mean()\n```\n\npropose d'utiliser deux types d'inputs (un `DataFrame Pandas` et une chaine de caract√®re)\net indique qu'elle renverra un `DataFrame Pandas`.\nA noter que c'est indicatif, non contraignant.\nEn effet, le code ci-dessus fonctionnera si on fournit en argument `col` une liste puisque `Pandas` sait g√©rer cela √† l'√©tape `df[col].mean()`.\n\nLe _type hinting_ est un √©l√©ment d'autodocumentation puisque gr√¢ce √† ces _hints_ le code\nsuffit √† faire comprendre la volont√© de la personne l'ayant √©crit. \n:::\n\n\nLa documentation vise √† pr√©senter la d√©marche g√©n√©rale, √©ventuellement\n√† travers des exemples, mais aussi √† expliciter certains √©l√©ments\ndu code (une op√©ration qui n'est pas √©vidente, des arguments de fonction, etc.). \nLa documentation se m√©lange donc aux instructions visant √† √™tre ex√©cut√©es\nmais s'en distingue. Ces principes sont h√©rit√©s du paradigme de la \n**\"programmation lettr√©e\"** (_Literate programming_) dont l'un des \navocats √©tait Donald Knuth. \n\n\n> _\"Je crois que le temps est venu pour une am√©lioration significative de la documentation des programmes, et que le meilleur moyen d'y arriver est de consid√©rer les programmes comme des ≈ìuvres litt√©raires. D'o√π mon titre, ¬´ programmation lettr√©e ¬ª._\n>\n> _Nous devons changer notre attitude traditionnelle envers la construction des programmes : au lieu de consid√©rer que notre t√¢che principale est de dire √† un ordinateur ce qu'il doit faire, appliquons-nous plut√¥t √† expliquer √† des √™tres humains ce que nous voulons que l'ordinateur fasse._\n>\n> _Celui qui pratique la programmation lettr√©e peut √™tre vu comme un essayiste, qui s'attache principalement √† exposer son sujet dans un style visant √† l'excellence. Tel un auteur, il choisit , avec soin, le dictionnaire √† la main, les noms de ses variables et en explique la signification pour chacune d'elles. Il cherche donc √† obtenir un programme compr√©hensible parce que ses concepts sont pr√©sent√©s dans le meilleur ordre possible. Pour cela, il utilise un m√©lange de m√©thodes formelles et informelles qui se compl√®tent\"_\n>\n> Donald Knuth, _Literate Programming_ ([source](https://fr.wikipedia.org/wiki/Programmation_lettr%C3%A9e))\n\nCela peut amener √† distinguer deux types de documentation :\n\n1. Une documentation g√©n√©rale de type `Jupyter Notebook` ou `Quarto Markdown` qui \npr√©sente certes du code ex√©cut√© mais dont l'objet principal est de pr√©senter\nune d√©marche ou des r√©sultats ;\n2. Une documentation de la d√©marche plus proche du code dont l'un des \nexemples sont les _docstrings_ `Python` (ou son √©quivalent `R`, la documentation `Roxygen`).\n\n",
    "supporting": [
      "code-quality_files"
    ],
    "filters": [],
    "includes": {}
  }
}