{"title":"Améliorer la qualité de son code","markdown":{"yaml":{"title":"Améliorer la qualité de son code","date":"2022-03-03","author":"Romain Avouac et Lino Galiana","draft":false,"layout":"single"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\n\n## L'enjeu d'un code lisible et maintenable\n\n> The code is read much more often than it is written.\n>\n> <div title=\"Guido Van Rossum est le créateur de Python, c'est donc quelqu'un qu'il vaut mieux écouter\">Guido Van Rossum</div>\n\nLorsque l'on s'initie à la pratique de la *data science*, il est assez naturel de voir le code d'une manière très fonctionnelle : je veux réaliser une tâche donnée — par exemple un algorithme de classification — et je vais donc assembler dans un *notebook* des bouts de code, souvent trouvés sur internet, jusqu'à obtenir un projet qui réalise la tâche voulue. La structure du projet importe assez peu, tant qu'elle permet d'importer correctement les données nécessaires à la tâche en question. Si cette approche flexible et minimaliste fonctionne très bien lors de la phase d'apprentissage, il est malgré tout indispensable de s'en détacher à progressivement à mesure que l'on progresse et que l'on peut être amené à réaliser des projets plus professionnels ou bien à intégrer des projets collaboratifs.\n\nEn particulier, il est important de proposer, parmi les multiples manières de résoudre un problème informatique, une solution qui soit intelligible par d'autres personnes parlant le langage. Le code est en effet lu bien plus souvent qu'il n'est écrit, c'est donc avant tout un outil de communication. De même, la maintenance d'un code demande généralement beaucoup plus de moyens que sa phase de développement initial, il est donc important de penser en amont la qualité de son code et la structure de son projet de sorte à le rendre au maximum maintenable dans le temps. Afin de faciliter ces réflexions, des tentatives plus ou moins institutionnalisées de définir des conventions ont émergé. Ces conventions dépendent naturellement du langage utilisé, mais les principes sous-jacents s'appliquent de manière universelle à tout projet basé sur du code.\n\n## De l'importance de suivre les conventions\n\n`Python` est un langage très lisible.\nAvec un peu d’effort sur le nom des objets,\nsur la gestion des dépendances et sur la structure du programme,\non peut très bien comprendre un script sans avoir besoin de l’exécuter.\nC'est l'une des principales forces du langage `Python` qui permet ainsi\nune acquisition rapide des bases.\n`R`, dans sa version de base, est un langage un peu plus verbeux que\n`Python`.\nCependant, les packages les plus utiles pour l'analyse de données (notamment\n`dplyr` ou `data.table`) offrent une grammaire un peu plus transparente.\n\nLa communauté `Python` a abouti à un certain nombre de normes,\ndites `PEP` (_Python Enhancement Proposal_),\nqui constituent un standard dans l’écosystème Python.\nLes deux normes les plus connues sont la norme `PEP8` (code)\net la norme `PEP257` (documentation).\n\nDans l'univers `R`, la formalisation\na été moins organisée. Ce langage est plus permissif que `Python`\nsur certains aspects[^1].\nNéanmoins, des standards ont émergé, à travers\nun certain nombre de _style guides_ dont les plus connus\nsont le\n[_tidyverse style guide_](https://style.tidyverse.org/googl) et le\n[_google style guide_](https://google.github.io/styleguide/Rguide.html)[^2]\n(voir [ce post](https://blog.r-hub.io/2022/03/21/code-style/) qui pointe vers\nun certain nombre de ressources sur le sujet).\n\nCes conventions ne sont pas immuables: les langages et leurs usages\névoluent, ce qui nécessite de mettre à jour les conventions. Cependant,\nadopter dans la mesure du possible certains des réflexes préconisés par ces\nconventions devrait améliorer la capacité à être compris par la communauté,\naugmenter les chances de \nbénéficier d'apport de celle-ci pour adapter le code mais aussi réduire la \ndifficulté à faire évoluer un code.\nIl existe beaucoup de philosophies différentes sur le style de codage et,\nen fait, le plus important est\nla cohérence :\nsi on choisit une convention, par exemple _snake case_ plutôt que\n_camel case_, le mieux est de s'y tenir. \n\n[^1]: Par exemple, en `R`, il est possible d'utiliser `<-` ou `=`\npour l'assignation,\non ne recontre pas d'erreur en cas de mauvaise indentation...\n\n[^2]: Il existe d'autres guides de style notamment le [MLR style guide](https://github.com/mlr-org/mlr3/wiki/Style-Guide#theoretical-style-guide)\nqui est un _framework_ orienté objet de _Machine Learning_ en `R`.\n\n\nLes conventions vont au-delà de la syntaxe. Un certain nombre de standards\nd'organisation d'un projet ont émergé.\nLa structuration d'un projet\npermet d'immédiatement identifier les éléments de code et les éléments\nannexes (par exemple les dépendances à gérer, la documentation, etc.).\nUn certain nombre d'assistants au développement de projets orientés données\n(des packages d'_helpers_, des extensions aux environnements\nde développement comme `VisualStudio` ou `RStudio`...) ont \némergé pour gagner en productivité et faciliter le\nlancement d'un projet (voir\n[ce post très complet sur les extensions VisualStudio](https://realpython.com/advanced-visual-studio-code-python/)). \nL'idée générale est de privilégier une structure de projet\nbien plus fiable qu'une suite sans structure de scripts\nou un notebook jupyter (voir [ce post de blog sur ce sujet](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)).\n\n## Comment adopter ces bonnes pratiques ?\n\nLes éléments exposés dans ce chapitre ne sont pas exhaustifs. Ils visent à pointer vers quelques problématiques prioritaires tout en proposant des conseils pratiques. Ils sont complémentaires du [guide des bonnes pratiques `utilitR`](https://www.pratiques.utilitr.org) qui vise à présenter de manière plus formelle quelques recommendations.\n\nDans la lignée de la vision des bonnes pratiques comme continuum proposée en [introduction]({{< ref \"/content/introduction.md\" >}}), il n'est pas nécessairement souhaitable d'appliquer toutes les recommendations présentées dans ce chapitre à chaque projet. Nous recommandons de les voir plutôt comme des bonnes habitudes à acquérir en opérant un va-et-vient régulier entre la pratique et la théorie. Par exemple, à la lecture de ce chapitre, vous allez certainement retenir en particulier certaines règles qui tranchent avec vos pratiques actuelles. Vous pouvez alors essayer d'appliquer ces nouvelles règles pendant un certain temps puis, lorsque celles-ci seront devenues naturelles, revenir à ce guide et appliquer le processus à nouveau. En procédant ainsi de manière incrémentale, vous améliorerez progressivement la qualité de vos projets sans avoir l'impression de passer trop de temps sur des micro-détails, au détriment des objectifs globaux du projet.\n\n# Qualité du code\n\n## Principes généraux\n\n\nLes premières conventions à évoquer ont trait à la syntaxe du code et\nont les objectifs suivants, qui seront détaillés par la suite :\n\n- [Améliorer la lisibilité](#lisibilite) ce qui est indispensable pour\nrendre la démarche intelligible par d'autres mais aussi pour soi, lorsqu'on\nreprend un code écrit il y a quelques temps ;\n- [Favoriser la concision](#concision) pour réduire le risque d'erreur\net rendre la démarche plus claire ;\n- Suivre les règles explicites ou les conventions d'un langage pour\n[assurer le fonctionnement et la cohérence](#coherence) d'un code ;\n- [Limiter la redondance](#redondance) ce qui permet de simplifier\nun code (paradigme du _don't repeat yourself_) ;\n- [Documenter un code](#documentation) ce qui facilite son acquisition\npar d'autres (à condition de ne pas aller dans l'excès de documentation).\n\n\n### Lisibilité  {#lisibilite}\n\nUn code écrit avec des noms de variables et de fonctions explicites est autant,\nvoire plus, informatif que les commentaires qui l’accompagnent.\nC’est pourquoi il est essentiel de respecter des conventions pour le\nchoix des noms des objets afin d’assurer la lisibilité des programmes.\n\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\nUn certain nombre de conseils sont présents dans le [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/style/)\nqui vise à faire connaître les préceptes du _\"Zen of Python\"_ (PEP 20).\n[Ce post de blog](https://towardsdatascience.com/the-zen-of-python-a-guide-to-pythons-design-principles-93f3f76d088a) illustre quelques uns\nde ces principes avec des exemples.\nVous pouvez retrouver ces conseils dans `Python` en \ntapant le code suivant:\n\n```python\nimport this\n```\n\n```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```\n\n\n\nVoici quelques conseils complémentaires. \n\n- Adopter les mêmes standards que la communauté pour les noms de package\n\n```python\n# bien\nimport numpy as np\n\n# trompeur\nimport numpy as pd\n```\n\n- Faire attention aux _namespaces_ pour éviter les conflits entre fonctions.\nCela implique de ne pas importer l'ensemble des fonctions d'un package de\nla manière suivante:\n\n```python\nfrom numpy import *\nfrom math import *\n```\n\nDans ce cas, on va se retrouver avec des conflits potentiels entre les\nfonctions du package `numpy` et du package `math` qui portent le même\nnom (`floor` par exemple). \n\n\n{{% /panel %}}\n{{% panel name=\"R\" %}}\n\n- Les fonctions de base `R` utilisent des points dans les noms de fonctions\n(`contrib.url()` par exemple) ou les noms de classes (`data.frame`).\nIl est mieux de réserver les points uniquement aux objets de classe `S3`\nsous la forme `fonction.classe` (approche de programmation orientée objet).\n\n- Privilégier le _snake case_, (écriture avec des *underscores*, par exemple `donnees_menages`)\nau _CamelCase_\n(écriture avec des majuscules en début de nouveau mot, par exemple `donneesMenages`)\n(préconisation du [tidyverse style guide](https://style.tidyverse.org/syntax.html)).\nSi vous préférez le _CamelCase_, utilisez-le systématiquement dans tout le script pour uniformiser le code.\n\n- Ne pas utiliser `T` ou `F` pour nommer des variables\n(car en plus d'être rarement des noms explicites ce sont les abréviations des booléens `TRUE` et `FALSE`)\n\n- Ne pas utiliser de noms qui sont déjà des fonctions de base `R` (`mean` par exemple).\nCela ne génère pas toujours d'erreur mais cela évite des erreurs difficilement détectables! Voici un exemple d'erreur difficile à détecter:\n\n```r\n# On commence avec équivalence TRUE et T\nTRUE == T\n2 == TRUE\n# On crée une variable T à un moment (shortcut de TRUE)\nT <- 2\n# On a rompu l'équivalence entre T et TRUE\nTRUE == T\n2 == T\n```\n\n- Le `return` n'est pas obligatoire en `R` mais il peut être utile\nd'expliciter l'objet retourné.\nLe [tidyverse style guide](https://style.tidyverse.org/functions.html#return)\nrecommande de ne pas le faire, le [Google style guide](https://google.github.io/styleguide/Rguide.html#use-explicit-returns)\nrecommande de toujours expliciter. Nous recommandons de toujours mettre un\n`return`.\n{{% /panel %}}\n{{< /panelset  >}}\n\nEn complément de ces premières recommandations, il est conseillé\nde suivre ces deux principes lorsqu'on commence à programmer\ndes fonctions (ce qui, comme cela est évoqué plus bas, est\ntoujours recommandé).\n\n- Faire attention au type d'objet renvoyé par `Python` ou `R`.\nCes deux langages ne proposent pas de typage\nfort,\nil est donc possible qu'une fonction renvoie des objets de nature différente\nen fonction, par exemple,\nde conditions `if` (selon les cas une liste, un vecteur,\nun dataframe, etc.). Cela peut amener à des surprises lorsqu'on utilise une \ntelle fonction dans un code. Il est recommandé d'éviter ce comportement\nen proposant des fonctions différentes si l'_output_ d'une fonction\nest de nature différente. Ce principe de précaution (mais aussi d'information)\nrenvoie au paradigme de\nla [programmation défensive](https://en.wikipedia.org/wiki/Defensive_programming).\n\n- Privilégier la programmation orientée objet lorsqu'une fonction doit\ns'adapter au type d'objet en entrée (par exemple aller chercher des\néléments différents pour un objet `lm` ou un objet `glm`).\nCela évite les codes _spaghetti_ :spaghetti: inutilement complexes qui sont impossibles à débugger.\n\n{{% box status=\"hint\" title=\"Hint\" icon=\"fa fa-lightbulb\" %}}\n\n`Python` propose une fonctionalité assez plaisante qui est\nle _`type hinting`_\n([doc officielle](https://docs.python.org/3/library/typing.html)\net [tutoriel sur realpython.com](https://realpython.com/lessons/type-hinting/)).\nCelle-ci permet d'indiquer le type d'argument attendu par une fonction\net celui qui sera renvoyé par la fonction. Par exemple, la personne ayant écrit la fonction suivante \n\n```python\ndef calcul_moyenne(df: pd.DataFrame, col : str = \"y\") -> pd.DataFrame:\n    return df[col].mean()\n```\n\npropose d'utiliser deux types d'inputs (un `DataFrame pandas` et une chaine de caractère) et indique qu'elle renverra un `DataFrame pandas`. A noter que c'est indicatif, non contraignant. En effet, le code ci-dessus fonctionnera si on fournit en argument `col` une liste puisque `pandas` sait gérer cela à l'étape `df[col].mean()`\n\n{{% /box %}}\n\n<br>\n\n{{% box status=\"note\" title=\"Note: le code spaghetti :spaghetti: \" icon=\"fa fa-comment\" %}}\nLe code `spaghetti` est un style d'écriture qui favorise l'apparition du syndrome du plat de spaghettis : \nun code impossible à déméler parce qu'il fait un usage excessif de conditions, d'exceptions en tous sens, de gestion des événements complexes. Il devient quasi-impossible de savoir quelles ont été les conditions à l'origine de telle ou telle erreur sans exécuter ligne à ligne (et celles-ci sont excessivement nombreuses du fait de mauvaises pratiques de programmation) le programme. \n\nEn fait, la programmation spaghetti qualifie tout ce qui ne permet pas de déterminer le qui, le quoi et le comment. Le code est donc plus long à mettre à jour car cela nécessite de remonter un à un le fil des renvois.\n\n{{% /box %}}\n\n### Concision  {#concision}\n\nComme une démonstration mathématique, un code intelligible \ndoit viser la concision et la simplicité. Les codes très longs\nsont souvent signes de répétitions et sont difficiles à débugger. \n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n- Privilégier les `list comprehensions` lorsque cela est possible:\n\n```python\nliste_nombres = range(10)\n\n# très mauvais\ny = []\nfor x in liste_nombres:\n  y.append(x*x)\n\n# mieux\ny = [x*x for x in liste_nombres]\n```\n\n- Privilégier les appels à des fonctions à des blocs \ncopier-coller\nen changeant un seul détail. \n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\n- Le code `R` base ci-dessous est très difficile à comprendre ;\n- Le code `dplyr` est plus intelligible mais est encore relativement verbeux ;\n- Le code `data.table` est plus concis, ce qui le rend plus clair (et plus\nproche de la syntaxe SQL).\n\n<table class='table' style = \"width : 70%;\">\n<tr> <td>\n\n**`Base R`**\n\n</td> \n<td>\n\n```r\naggregate(\n  dt[dt[[\"x\"]] > 3]$y,\n  by = list(dt[dt[[\"x\"]] > 3]$z),\n  FUN = sum)\n```\n\n</td>\n</tr>\n<tr>\n<td>\n\n**`dplyr`**\n\n</td> \n<td>\n\n```r\ndt %>%\n  dplyr::filter(x > 3) %>%\n  dplyr::group_by(z) %>%\n  dplyr::summarise(sum(y))\n```\n\n</td>\n</tr>\n<tr>\n<td>\n\n**`data.table`**\n\n</td> \n<td>\n\n```r\ndt[x > 3, sum(y), by = z]\n```\n</td>\n</tr>\n</table>\n\n{{% /panel %}}\n{{< /panelset >}}\n\n\n### Cohérence interne {#coherence}\n\nLister les dépendances est important,\ntant pour des raisons techniques (que le logiciel sache où aller\nchercher des fonctions nécessaires pour avoir un code fonctionnel)\nque pour des raisons conventionnelles (que les utilisateurs comprennent les\ndépendances à s'installer pour être en mesure de réutiliser le code). \n\nPour cette raison, il est de bonne pratique de lister les dépendances\nde deux manières.\n\n:one: En début de script, l'ensemble des fonctions issues de librairies externes\nou les packages à importer doivent être listés ;\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\nLes imports se mettent conventionnellement en début de script, qu'il s'agisse d'import de packages dans leur ensemble ou seulement de certaines fonctions:\n\n```python\nimport pandas as pd\nfrom sklearn.model_selection import cross_val_score\n```\n\nDans le premier cas, on fait ensuite référence aux fonctions en les faisant \nprécéder du nom du package :\n\n```python\npd.DataFrame([0,1])\n```\n\nCela permet de dire à `Python` d'aller chercher dans le _namespace_ `pd` (alias pour `pandas` qui est lui-même un ensemble de scripts enregistrés sur le disque) la fonction `DataFrame`.\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\n`R` ne permet que l'import de la librairie dans son ensemble (sauf dans les _packages_, nous verrons cela plus tard).\n\n```r\nlibrary(data.table)\n```\n\nEnsuite, on peut faire référence directement aux fonctions du package, par exemple `data.table`. Cependant, il est recommandé de privilégier la notion `pkg::function` (ici `data.table::data.table`) qui permet à `R` d'être certain d'aller chercher la fonction dans le bon _namespace_\n\n{{% /panel %}}\n{{< /panelset >}}\n\n:two: Dans un fichier externe (voir la [partie structure](#structure) et le chapitre portabilité),\nles dépendances à installer sont listées.\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\nIl s'agit du fichier `requirements.txt`\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\nIl s'agit du fichier `DESCRIPTION`\n\n{{% /panel %}}\n{{< /panelset >}}\n\n\nUn code reproductible doit pouvoir s'exécuter de manière linéaire.\nS'il provoque une erreur, il est important de pouvoir identifier\nl'instruction responsable pour pouvoir _debugger_.\n\nLes scripts trop longs ne sont pas une bonne pratique. Il est préférable\nde diviser l'ensemble des scripts exécutant une\nchaîne de production en \"monades\"\", c'est-à-dire en petites unités\ncohérentes. Les fonctions sont un outil privilégié pour cela\n(en plus de limiter la redondance, et d'être un outil privilégié\npour documenter un code).\n\n\n### Limiter la redondance {#redondance}\n\nUn bon principe à suivre est _\"don't repeat yourself !\"_ (DRY).\nCelui-ci réduit la charge de code à écrire, à comprendre et à \ntenir à jour. \n\n{{< tweet 598532170160873472 >}}\n\nCe [post](https://www.earthdatascience.org/courses/intro-to-earth-data-science/write-efficient-python-code/intro-to-clean-code/dry-modular-code/) donne quelques bonnes pratiques\npour réduire la redondance des codes. \n\nSupposons qu'on dispose d'une table de données qui utilise le code `−99` pour représenter les valeurs manquantes. On désire remplacer l'ensemble des `−99` par des `NA`.\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n```python\n# On fixe la racine pour être sûr de tous avoir le même dataset\nnp.random.seed(1234)\n\n# On créé un dataframe\na = np.random.randint(1, 10, size = (5,6))\ndf = np.insert(\n    a,\n    np.random.choice(len(a), size=6),\n    -99,\n)\ndf = pd.DataFrame(df.reshape((6,6)), columns=[chr(x) for x in range(97, 103)])\n```\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\n```r\n# On fixe la racine pour être sûr de tous avoir le même dataset\nset.seed(1014)\n\n# On créé un dataframe\ndf <- data.frame(replicate(6, sample(c(1:10, -99), 6, rep = TRUE)))\nnames(df) <- letters[1:6]\n```\n\n\n{{% /panel %}}\n{{< /panelset >}}\n\nUn premier jet de code pourrait prendre la forme suivante:\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n```python\n# Dupliquer les données\ndf2 = df.copy()\n# Remplacer les -99 par des NA\ndf2.loc[df2['a'] == -99,'a'] = np.nan\ndf2.loc[df2['b'] == -99,'b'] = np.nan\ndf2.loc[df2['c'] == -99,'c'] = np.nan\ndf2.loc[df2['d'] == -99,'d'] = np.nan\ndf2.loc[df2['e'] == -98,'e'] = np.nan\ndf2.loc[df2['f'] == -99,'e'] = np.nan\n```\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\n```r\n# Dupliquer les données\ndf2 <- df\n# Remplacer les -99 par des NA\ndf2$a[df2$a == -99] <- NA\ndf2$b[df2$b == -99] <- NA\ndf2$c[df2$c == -99] <- NA\ndf2$d[df2$d == -99] <- NA\ndf2$e[df2$e == -98] <- NA\ndf2$f[df2$e == -99] <- NA\ndf2\n```\n\n\n{{% /panel %}}\n{{< /panelset >}}\n\nQuelles sont les choses qui vous dérangent dans le code ci-dessus? Indice: regardez précisément le code et le dataframe (indice: surveillez la colonne `e` et la colonne `g`).\n\nOn peut noter au moins deux problèmes:\n\n* Le code est long et répétitif, ce qui nuit à sa lisibilité;\n* Le code est très dépendant de la structure des données (nom et nombre de colonnes) et doit être adapté dès que celle-ci évolue;\n* On a introduit une erreur humaine dans le code, difficile à détecter, dans l'instruction concernant la colonne `e`. \n\nOn voit dans la première version de notre code qu'il y a une structure commune à toutes nos lignes de la forme `.[. == -99] <- NA`. Cette structure va servir de base à notre fonction, en vue de généraliser le traitement que nous voulons faire.\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n```python\ndef fix_missing(x: pd.Series):\n    x[x == -99] = np.nan\n    return x\n\ndf2 = df.copy()\ndf2['a'] = fix_missing(df['a'])\ndf2['b'] = fix_missing(df['b'])\ndf2['c'] = fix_missing(df['c'])\ndf2['d'] = fix_missing(df['d'])\ndf2['e'] = fix_missing(df['e'])\ndf2['f'] = fix_missing(df['f'])\n```\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\n```r\nfix_missing <- function(x) {\n  x[x == -99] <- NA\n  x\n}\ndf2 <- df\ndf2$a <- fix_missing(df2$a)\ndf2$b <- fix_missing(df2$b)\ndf2$c <- fix_missing(df2$c)\ndf2$d <- fix_missing(df2$d)\ndf2$e <- fix_missing(df2$e)\ndf2$f <- fix_missing(df2$f)\ndf2\n```\n\n{{% /panel %}}\n{{< /panelset >}}\n\nCette seconde version du code est meilleure que la première version, car on a réglé le problème d'erreur humaine (il n'est plus possible de taper `-98` au lieu de `-99`). Mais le code reste long et répétitif, et n'élimine pas encore toute possibilité d'erreur, car il est toujours possible de se tromper dans le nom des variables. \n\nLa prochaine étape est ainsi d'éliminer ce risque d'erreur en combinant deux fonctions (ce qu'on appelle combinaison de fonctions). La première `fix_missing()` sert à régler le problème sur un vecteur. La seconde généralisera ce procédé à toutes les colonnes. Comme `R` est un langage vectoriel, c'est une approche fréquente de construire des fonctions sur des vecteurs et les appliquer ensuite à plusieurs colonnes.\n\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n```python\ndef fix_missing(x: pd.Series):\n    x[x == -99] = np.nan\n    return x\ndf2 = df.copy()\ndf2 = df2.apply(fix_missing)\n```\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\nIl est possible d'appliquer `lapply` à un `dataframe` car un `dataframe` est en fait une liste de vecteurs (les colonnes du `dataframe`). Toutefois, comme `lapply` renvoie une liste, on a besoin d'utiliser une petite astuce pour s'assurer que la sortie de la fonction prenne la forme d'un `dataframe` et non d'une liste. A la place d'assigner le résultat sous la forme `df <- lapply(.....)` on va faire `df[] <- lapply(...)`. Ecrivez la boucle `lapply` permettant d'appliquer `fix_missing` a l'ensemble des colonnes du *dataframe*:\n\n```r\ndf2 <- df\n# Définir une fonction\nfix_missing <- function(x) {\n  x[x == -99] <- NA\n  x\n}\n# Appliquer la fonction à toutes les colonnes du dataframe\ndf2[] <- lapply(df2, fix_missing)\ndf2\n```\n\n{{% /panel %}}\n{{< /panelset >}}\n\nCette troisième version du code a plusieurs avantages sur les deux autres versions:\n\n1. Elle est plus concise et plus lisible;\n2. Si on a un changement de code pour les valeurs manquantes, il suffit de le mettre à un seul endroit;\n3. Elle fonctionne quels que soient le nombre de colonnes et le nom des colonnes;\n4. On ne peut pas traiter une colonne différemment des autres par erreur.\n\nDe plus, le code est facilement généralisable. Par exemple, à partir de la même structure, écrire le code qui permet de ne traiter que les colonnes *a*,*b* et *e*.\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n```python\ndf2 = df.copy()\ndf2[['a','b','e']] = df2[['a','b','e']].apply(fix_missing)\n```\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\n```r\ndf2 <- df\ndf2[c(\"a\",\"b\",\"e\")] <- lapply(c(\"a\",\"b\",\"e\"), function(col) fix_missing(df2[col]))\n```\n\n{{% /panel %}}\n{{< /panelset >}}\n\n\n\n### Documentation {#documentation}\n\nUn code sans aucun commentaire est très difficile à s'approprier (y compris\npour la personne qui l'a rédigé et qui y revient quelques semaines plus tard).\nCependant, un code présentant trop de commentaires est également illisible et\nreflète généralement un défaut de conception du code qui n'est pas assez\nexplicite. \n\nLa documentation vise à présenter la démarche générale, éventuellement\nà travers des exemples, mais aussi à expliciter certains éléments\ndu code (une opération qui n'est pas évidente, des arguments de fonction, etc.). \nLa documentation se mélange donc aux instructions visant à être exécutées\nmais s'en distingue. Ces principes sont hérités du paradigme de la \n_\"programmation lettrée\"_ (_Literate programming_) dont l'un des \navocats était Donald Knuth. \n\n\n> \"Je crois que le temps est venu pour une amélioration significative de la documentation des programmes, et que le meilleur moyen d'y arriver est de considérer les programmes comme des œuvres littéraires. D'où mon titre, « programmation lettrée .\n>\n> Nous devons changer notre attitude traditionnelle envers la construction des programmes : au lieu de considérer que notre tâche principale est de dire à un ordinateur ce qu'il doit faire, appliquons-nous plutôt à expliquer à des êtres humains ce que nous voulons que l'ordinateur fasse.\n>\n> Celui qui pratique la programmation lettrée peut être vu comme un essayiste, qui s'attache principalement à exposer son sujet dans un style visant à l'excellence. Tel un auteur, il choisit , avec soin, le dictionnaire à la main, les noms de ses variables et en explique la signification pour chacune d'elles. Il cherche donc à obtenir un programme compréhensible parce que ses concepts sont présentés dans le meilleur ordre possible. Pour cela, il utilise un mélange de méthodes formelles et informelles qui se complètent\"\n>\n> Donald Knuth, _Literate Programming_ ([source](https://fr.wikipedia.org/wiki/Programmation_lettr%C3%A9e))\n\nCela peut amener à distinguer deux types de documentation:\n\n1. Une documentation générale de type `Jupyter Notebook` ou `R Markdown` qui \nprésente certes du code exécuté mais dont l'objet principal est de présenter\nune démarche ou des résultats\n2. Une documentation de la démarche plus proche du code dont l'un des \nexemples sont les _docstrings_ `Python` ou la documentation `Roxygen`\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n- PEP 8, PEP 257\n\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\nL'exemple suivant, issu du livre de référence\nd'Hadley Wickham et Jenny Bryan _R Packages_ permet de mesurer\nl'intérêt de la documentation standardisée (bien-sûr ici la\nfonction est assez explicite mais cela permet de se concentrer\nsur la documentation). \n\nLes balises `Roxygen` s'insèrent autour de la définition d'une\nfonction. Elles permettent à la lecture du code source de bien\ncomprendre l'objectif de la fonction ainsi que ses inputs. On\na même ici des exemples qui permettent de tester la fonction.\n\n```r\n#' Add together two numbers\n#' \n#' @param x A number.\n#' @param y A number.\n#' @return The sum of \\code{x} and \\code{y}.\n#' @examples\n#' add(1, 1)\n#' add(10, 1)\nadd <- function(x, y) {\n  x + y\n}\n```\n\nCeci est déjà explicite à la lecture du code source. Cependant,\nun avantage de cette structuration imposée de la documentation est\nqu'ensuite, si la fonction est introduite dans un _package_,\nla documentation de la fonction, accessible via `?add` par\nexemple, est automatiquement mise en forme:\n\n![](https://d33wubrfki0l68.cloudfront.net/b97dc657a7e1c7030d1b8d188723fb10f5260474/3dc52/images/man-add.png)\n\n{{% /panel %}}\n{{< /panelset >}}\n\n\n\n## Standards communautaires de code\n\nPour parler le même langage, un certain nombre de conventions ont\némergé dans les communautés `R` et `Python`. L'objectif ici \nn'est pas de lister ces conventions (une partie d'entre elles ayant\ndéjà été évoquées) mais pointer rapidement vers les principales\nconventions. \nDans le domaine, `Python` a crée un système un peu plus formel que\n`R` mais globalement, la démarche est la même. \n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n- PEP 8, PEP 257\n\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\nLes incontournables sont :\n\n- [_tidyverse style guide_](https://style.tidyverse.org/googl)\n- [_google style guide_](https://google.github.io/styleguide/Rguide.html)\n* [Le guide du développeur Ropensci](https://devguide.ropensci.org/index.html)\n\n`Ropensci` a également lancé un appel à contribution pour proposer\nun guide des bonnes pratiques adapté aux projets de données \ngouvernementaux\n[sur Github](https://github.com/ropensci-org/community-calls/issues/26).\nL'OCDE devrait également lancer un manuel sur le sujet dans les prochains\nmois. \n\n{{% /panel %}}\n{{< /panelset >}}\n\n## Outils et méthodes pour améliorer un code\n\n### Helpers\n\n`Python` ou `R` étant l'outil de travail principal de milliers de \n_data-scientists_, un certain nombre d'outils ont vu le jour\npour réduire le temps nécessaire pour créer un projet ou disposer\nd'un code fonctionnel. Ces outils permettent un gros gain de productivité,\nréduisent le temps passé à effectuer des tâches rébarbatives et améliorent\nla qualité d'un projet en offrant des diagnostics voire des correctifs\nà des codes perfectibles. \n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\nLa première chose à faire est de privilégier\nles projets RStudio (\n[voir la présentation de ceux-ci dans la documentation `utilitR`](https://www.book.utilitr.org/rproject.html)\net les éléments présentés dans la partie sur la\n[structuration des projets](#structure)).\n\nLes packages suivants font partie de la palette du développeur: \n\n* [`usethis`](https://usethis.r-lib.org/): s'il fallait n'en retenir qu'un (ce\nqui serait tout de même un peu dommage...). Le couteau-suisse de la création\net de la gestion des options d'un projet\n* [`devtools`](https://github.com/r-lib/devtools): le meilleur ami de la\npersonne qui développe les packages. Le livre [R Packages](https://r-pkgs.org/index.html)\ndonne de nombreux exemples à son propos. \n* [`here`](https://here.r-lib.org/): pour en finir avec la galère des chemins\nrelatifs, des dossiers de travail, etc.\n* [`Roxygen`](https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html): \nle package dédié à la documentation des fonctions\n* [`goodpractice`](https://github.com/MangoTheCat/goodpractice): des diagnostics\npratiques sur la qualité du code\n\nEnfin, `RStudio` propose de nombreux _addins_ (extensions) bien pratiques.\nLa plupart sont installés avec des _packages_ de _helpers_, n'hésitez\npas à en tester quelques uns. \n\n{{% /panel %}}\n{{< /panelset >}}\n\n### Analyse de code\n\n-   linters\n-   formatters\n\nLes _linters_ sont des outils qui permettent d'évaluer la qualité du \ncode et son risque de provoquer une erreur (explicite ou silencieuse).\nVoici quelques exemples de problèmes que peuvent rencontrer les \n`linters`:\n\n* les variables sont utilisées mais n'existent pas (erreur)\n* les variables inutilisées (inutiles)\n* la mauvaise organisation du code (risque d'erreur)\n* le non respect des bonnes pratiques d'écriture de code\n* les erreurs de syntaxe (par exemple les coquilles)\n    \nLa plupart des logiciels de développement embarquent des fonctionalités\nde diagnostic (voire de suggestion de correctif). Il faut parfois\nles paramétrer dans les options (ils sont désactivés pour ne pas\neffrayer l'utilisateur avec des croix rouges partout)\n\n{{< panelset class=\"nommage\" >}}\n{{% panel name=\"Python :snake:\" %}}\n\n\n{{% /panel %}}\n\n{{% panel name=\"R\" %}}\n\nLes packages de référence dans le \ndomaine sont:\n\n- [`lintr`](https://github.com/r-lib/lintr) pour les diagnostics ;  \n- [`styler`](https://github.com/r-lib/styler) pour la modification\nautomatisée des fichiers suite au diagnostic.\n\n`RStudio` propose des diagnostics mais ils ne sont pas activés\npar défaut. Pour les activer, après avoir fait `Tools > Global Options` : \n\n1. Aller dans la partie `Code` à gauche\n2. Dans les onglets en haut, cliquer sur `Diagnostics`\n3. Ajouter quelques diagnostics (par défaut ceux-ci sont vraiment\ntrop peu nombreux)\n\n![](/rstudio-diagnostics.png)\n\nMême si vous ne développez pas de _packages_ ces diagnostics vous\npermettront d'améliorer la qualité de vos codes. \n\n{{% /panel %}}\n{{< /panelset >}}\n\n### Relecture par un tiers / pair-programming\n\n\n\n\n# Références\n\n- [The Hitchhiker’s Guide to Python](https://docs.python-guide.org/#writing-great-python-code)\n- [_tidyverse style guide_](https://style.tidyverse.org/googl)\n- [_google style guide_](https://google.github.io/styleguide/Rguide.html)\n- [Cours de Pierre-Antoine Champin](https://perso.liris.cnrs.fr/pierre-antoine.champin/enseignement/algo/cours/algo/bonnes_pratiques.html)\n- [R Packages](https://r-pkgs.org/index.html) par Hadley Wickham and Jenny Bryan\n- [La documentation collaborative `utilitR`](https://www.book.utilitr.org)\n- [Project Oriented Workflow](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)\n- [Un post très complet sur les extensions VisualStudio](https://realpython.com/advanced-visual-studio-code-python/)\n- [\"Coding style, coding etiquette\"](https://blog.r-hub.io/2022/03/21/code-style/)\n- [Une présentation très bien faite sur la gestion de code et de projets  `R`](https://mitmat.github.io/slides/2022-05-26-egu/code-data-open-science.html#1)\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"code-quality.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","theme":"cosmo","title":"Améliorer la qualité de son code","date":"2022-03-03","author":"Romain Avouac et Lino Galiana","draft":false,"layout":"single"},"extensions":{"book":{"multiFile":true}}}}}